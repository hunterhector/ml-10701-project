Tree-Local Multicomponent Tree-Adjoining Grammars with Shared Nodes Laura Kallmeyer ∗ TALaNa/Lattice, Universit´eParis7 This article addresses the problem that the expressive power of tree-adjoining grammars (TAGs) is too limited to deal with certain syntactic phenomena, in particular, with scrambling in freeword-order languages.
The TAG variants proposed so far in order to account for scrambling are not entirely satisfying.
Therefore, the article introduces an alternative extension of TAG that is based on the notion of node sharing, so-called (restricted) tree-local multicomponent TAG with shared nodes (RSN-MCTAG).
The analysis of some German scrambling data is sketched in order to show that this TAG extension can deal with scrambling.
Then it is shown that for RSN-MCTAGs of a specific type, equivalent simple range concatenation grammars can be constructed.
As a consequence, these RSN-MCTAGs are mildly context-sensitive and in particular polynomially parsable.
These specific RSN-MCTAGs probably can deal not with all scrambling phenomena, but with an arbitrarily large subset.
1. Introduction: LTAG and Scrambling 1.1 Lexicalized Tree-Adjoining Grammars Tree-adjoining grammar (TAG) is a tree-rewriting formalism originally defined by Joshi, Levy, and Takahashi (1975).
A TAG (see Joshi and Schabes 1997 for an introduction) consists of a finite set of trees (elementary trees).
The nodes of these trees are labeled with nonterminals and terminals (terminals label only leaf nodes).
Starting from the elementary trees, larger trees are derived using composition operations of substitution (replacing a leaf with a new tree) and adjunction (replacing an internal node with a new tree).
In the case of an adjunction, the tree being adjoined has exactly one leaf node that is marked as the foot node (marked with an asterisk).
Such a tree is called an auxiliary tree.
When such a tree is adjoined to a node µ, in the resulting tree, the subtree with root node µ from the old tree is put below the foot node of the new auxiliary tree.
Elementary trees that are not auxiliary trees are called initial trees.
Each derivation starts with an initial tree.
In the final derived tree, all leaves must have terminal labels.
1 ∗ UFR de Linguistique, Case 7003, 2 Place Jussiec, 75005 Paris.
E-mail: Laura.Kallmeyer@linguist.jussieu.fr. 1 Additionally, TAG allows for each internal node to specify the set of auxiliary trees that can be adjoined using so-called adjunction constraints and, furthermore, to specify whether adjunction at that node is obligatory.
This is an important feature of TAG, since it influences the generative capacity of the formalism: {a n b n c n d n |n ≥ 0}, for example, is a language that can be generated by a TAG with adjunction constraints but not by a TAG without adjunction constraints (Joshi 1985).
For this article, however, adjunction constraints do not play any important role.
Submission received: 1st September 2003; Revised submission received: 4th May 2004; Accepted for publication: 17th June 2004 © 2005 Association for Computational Linguistics Computational Linguistics Volume 31, Number 2 Figure 1 TAG derivation for John always laughs.
Figure 1 shows a sample TAG derivation.
Here, the three elementary trees for laughs, John, and always are combined: Starting from the elementary tree for laughs, the tree for John is substituted for the noun phrase (NP) leaf and the tree for always is adjoined at the verb phrase (VP) node.
TAG derivations are represented by derivation trees that record the history of how the elementary trees are put together.
A derivation tree is the result of carrying out substitutions and adjunctions.
Each edge in the derivation tree stands for an adjunction or a substitution.
The edges are labeled with Gorn addresses of the nodes where the substitutions and adjunctions have taken place: The root has the address epsilon1,andthejth child of the node with address p has address pj.
In Figure 1, for example, the derivation tree indicates that the elementary tree for John is substituted for the node at address 1 and always is adjoined at node address 2.
What we have sketched so far are the mathematical aspects of the TAG formalism.
For natural languages, TAGs with specific properties are used.
These properties are not part of the formalism itself, but they are additional linguistic principles that are respected when a TAG is constructed for a natural language.
First, a TAG for natural languages is lexicalized (Schabes 1990), which means that each elementary tree has a lexical anchor (usually unique, but in some cases, there is more than one anchor).
Second, the elementary trees of a lexicalized TAG (LTAG) represent extended projections of lexical items (the anchors) and encapsulate all syntactic arguments of the lexical anchor; that is, they contain slots (nonterminal leaves) for all arguments.
Furthermore, elementary trees are minimal in the sense that only the arguments of the anchor are encapsulated; all recursion is factored away.
This amounts to the condition on elementary tree minimality (CETM) from Frank (1992) (see also Frank [2002] for further discussions of the linguistic principles underlying TAG).
2 The
tree for laughs in Figure 1, for example, contains only a nonterminal leaf for the subject NP (a substitution node), and there is no slot for a VP adjunct.
The adverb always is added by adjunction at an internal node.
Because of these principles, in linguistic applications, combining two elementary trees by substitution or adjunction corresponds to the application of a predicate to an argument.
The derivation tree then reflects the predicate-argument structure of the sentence.
This is why most approaches to semantics in TAG use the derivation tree as an interface between syntax and semantics (see, e.g., Candito and Kahane 1998; Joshi and Vijay-Shanker 1999; Kallmeyer and Joshi 2003).
In this article, we are not particularly concerned with semantics, but one of the goals of the article is to obtain analyses with derivation trees representing the correct predicate-argument dependencies.
2 This
minimality is actually the reason that the substitution operation is needed; formally TAGs without substitution and TAGs as introduced above have the same weak and strong generative capacity.
188 Kallmeyer Multicomponent TAGs with Shared Nodes An extension of TAG that has been shown to be useful for several linguistic applications is multicomponent TAG (MCTAG) (Joshi 1987; Weir 1988).
Instead of single elementary trees, an MCTAG has sets of elementary trees.
In each derivation step, one of these sets is chosen, and all trees from the set are added simultaneously.
Depending on the nodes to which the different trees from the set attach, different kinds of MCTAGs are distinguished: If all nodes are required to be part of the same elementary tree, the MCTAG is called tree-local; if all nodes are required to be part of the same tree set, the grammar is set-local; and otherwise the grammar is nonlocal.
1.2 Scrambling
in TAG Roughly, scrambling can be described as the permutation of elements (arguments and adjuncts) of a sentence (we use the term scrambling in a purely descriptive sense without implying any theory involving actual movement).
A special case of scrambling is socalled long-distance scrambling, in which arguments or adjuncts of an embedded infinitive are “moved” out of the embedded VP.
This occurs, for instance, in languages such as German, Hindi, Japanese, and Korean.
As an example of long-distance scrambling in German, consider example (1): (1)...dass [es] 1 der Mechaniker [t 1 zu reparieren] verspricht ...thatit themechanic torepair promises ‘...thatthemechanicpromisestorepairit’ In example (1), the accusative NP es is an argument of the embedded infinitive zu reparieren, but it precedes der Mechaniker, the subject of the main verb verspricht,and it is not part of the embedded VP.
It has been argued (see Rambow 1994a) that in German, there is no bound on the number of scrambled elements and no bound on the depth of scrambling (i.e., in terms of movement, the number of VP borders crossed by the moved element).
TAGs are not powerful enough to describe scrambling in German in an adequate way (Becker, Joshi, and Rambow 1991).
By this we mean that a TAG analysis of scrambling respecting the CETM and therefore giving the correct predicate-argument structure (i.e., an analysis with each argument attaching to the verb it depends on) is not possible.
Let us consider the TAG analysis of example (1) in order to see why scrambling poses a problem for TAG.
If we leave aside the complementizer dass,standard TAG elementary trees for verspricht and reparieren in the style of the XTAG grammar (XTAG Research Group 1998) might look as shown in Figure 2.
In the derivation, the Figure 2 Standard TAG combination of der Mechaniker, zu reparieren,andverspricht in example (1).
189 Computational Linguistics Volume 31, Number 2 verspricht-tree adjoins to the root node of the reparieren-tree, and the nominative NP der Mechaniker is substituted for the subject node in the verspricht-tree.
This leads to the tree on the right in Figure 2.
When es is added, there is a problem: It should be added to reparieren, since it is one of its arguments.
But at the same time, it should precede der Mechaniker;thatis, it must be adjoined either to the root or to the NP nom node.
The root node belongs to verspricht,andtheNP nom node belongs to der Mechaniker.
Consequently, an adjunction to one of them would not give the desired predicate-argument structure.
If one wanted to analyze only example (1), one could add a tree to the grammar for reparieren with a scrambled NP that allows adjunction of verspricht between the NP and the verb.
But as soon as there are several scrambled elements that are arguments of different verbs, this no longer works.
This example has given an idea of why scrambling is problematic for TAG.
However, adopting specific elementary trees, it is possible to deal with a part of the difficult scrambling data: It has been shown (see Joshi, Becker, and Rambow 2000) that TAG can describe scrambling up to depth two (two crossed VP borders).
But this is not sufficient.
Even though examples of scrambling of depth greater than two are rare, they can occur.
An example is example (2), taken from Kulick (2000): (2) ...dass [den K¨uhlschrank] 1 niemand [[[t 1 zu reparieren] zu versuchen] ...thattherefrigerator nobody torepair totry zu versprechen] bereit ist to promise willing is ‘...thatnobodyiswilling to promise to try to repair the refrigerator’ Consequently, TAG is not powerful enough to account for scrambling.
3 Becker, Rambow, and Niv (1992) argue that even linear context-free rewriting systems (LCFRSs) (Weir 1988) are not powerful enough to describe scrambling.
(LCFRSs are weakly equivalent to set-local MCTAGs and therefore more powerful than TAGs.) Although we think that the language Becker, Rambow, and Niv define as a kind of test language for scrambling is not exactly what one needs (see section 2.3), we still suspect that they are right in claiming that LCFRSs cannot describe scrambling.
1.3 TAG
Variants Proposed for Scrambling The problem with long-distance scrambling and TAG is that the trees representing the syntax of scrambled German subordinate clauses do not have the simple nested structure that ordinary TAG generates.
The CETM requires that (positions for) all of the arguments of the lexical anchor of an elementary tree be included in that tree.
But in a scrambled tree, the arguments of several verbs are interleaved freely.
All TAG extensions that have been proposed to accommodate this interleaving involve factoring the elementary structures into multiple components and inserting these components at multiple positions in the course of the derivation.
One of the first proposals made was an analysis of German scrambling data using nonlocal MCTAG with additional dominance constraints (Becker, Joshi, and Rambow 1991).
However, the formal properties of nonlocal MCTAG are not well understood, and 3 See also Gerdes (2002) for a discussion of the limitation of TAG with respect to scrambling in German.
190 Kallmeyer Multicomponent TAGs with Shared Nodes it is assumed that the formalism is not polynomially parsable.
Therefore this approach is no longer pursued, but it has influenced the different subsequent proposals.
An alternative formalism for scrambling is V-TAG (Rambow 1994a, 1994b; Rambow and Lee 1994), a formalism that has nicer formal properties than nonlocal MCTAG.
V-TAG also uses multicomponent sets (vectors) for scrambled elements; in this it is a variant of MCTAG.
Additionally, there are dominance links among the trees of the same vector.
In contrast to MCTAG, the trees of a vector in V-TAG are not required to be added simultaneously.
The lexicalized V-TAGs that are of interest for natural languages are polynomially parsable.
Rambow (1994a) proposes detailed analyses of a large range of different word order phenomena in German using V-TAG and thereby shows the linguistic usefulness of V-TAG.
Even though V-TAG does not pose the problems of nonlocal MCTAG in terms of parsing complexity, it is still a nonlocal formalism in the sense that, as long as the dominance links are respected, arbitrary nodes can be chosen to attach the single components of a vector.
Therefore, in order to formulate certain locality restrictions (e.g., for wh-movement and also for scrambling), one needs an additional means of putting constraints on what can interleave with the different trees of a vector, or in other words, constraints on how far a dominance link can be stretched.
V-TAG allows us to put integrity constraints on certain nodes that disallow the occurrence of these nodes between two trees linked by a dominance link.
This has the effect of making these nodes act as barriers.
With integrity constraints, constructions involving long-distance movements can be correctly analyzed.
But the explicit marking of barriers is somewhat against the original appealing TAG idea that such constraints result from imposition of the CETM, according to which the position of the moved element and the verb it depends on must be in the same elementary structure, and from the further combination possibilities of this structure.
In other words, in local formalisms with an extended domain of locality such as TAG or tree-local and set-local MCTAG, such constraints result from the form of the elementary structures and from the locality of the derivation operation.
That is, they follow from general properties of the grammar, and they need not be stated explicitly.
This is one of the aspects that make TAG so attractive from a linguistic point of view, and it gets lost in nonlocal TAG variants.
D-tree substitution grammars (DSGs) (Rambow, Vijay-Shanker, and Weir 2001) are another TAG variant one could use for scrambling.
DSGs are a description-based formalism; that is, the objects a DSG deals with are tree descriptions.
A problem with DSG is that the expressive power of the formalism is probably too limited to deal with all natural language phenomena: According to Rambow, Vijay-Shanker, and Weir (2001) it “does not appear to be possible for DSG to generate the copy language” (page 101).
This means that the formalism is probably not able to describe cross-serial dependencies in Swiss German.
Furthermore, DSG is nonlocal and therefore, as in the case of V-TAG, additional constraints (path constraints) have to be placed on material interleaving with the different parts of an elementary structure.
Another TAG variant using tree descriptions is local tree description grammar (TDG) (Kallmeyer 2001).
Local TDG can be used for scrambling in a way similar to DSG or V-TAG.
The languages generated by local TDGs are semilinear.
However, the formalism allows one to generate tree descriptions with underspecified dominance relations, and the process of resolving the remaining dominance links is nonlocal.
Therefore one may have the same problem as in the case of DSG and V-TAG.
Furthermore, so far it has not been shown that the formalism is polynomially parsable, and it is not clear whether such parsing is possible without any additional constraint or limitation on the underspecified tree descriptions.
191 Computational Linguistics Volume 31, Number 2 A further TAG variant proposed in order to deal with scrambling is segmented treeadjoining grammar (SegTAG) (Kulick 2000).
SegTAG uses an operation on trees called segmented adjunction that consists partly of a standard TAG adjunction and partly of a kind of tree merging or tree unification.
In this operation, two different things get mixed up, the more or less resource-sensitive adjoining operation of standard TAG, in which subtrees cannot be identified, 4 and the completely different unification operation.
Perhaps using tree descriptions instead of trees, a more coherent definition of SegTAG can be achieved.
But we will not pursue this here.
The formal properties of SegTAG are not clear.
Kulick (2000) suggests that SegTAGs are probably in the class of LCFRSs, but there is no actual proof of this.
However, if SegTAG is in LCFRS, the generative power of the formalism is probably too limited to deal with scrambling in a general way.
But it seems that the limit imposed by the grammar on the complexity of the scrambling data is fixed but arbitrarily high.
(With increasing complexity, the elementary trees, however, get larger and larger).
This means that one can probably define a SegTAG that can analyze scrambling up to some complexity level n for any n ∈ IN.
(A definition of what a complexity level is, is not given; it is perhaps the depth of scrambling).
In this sense, a general treatment of scrambling might be possible.
We follow a similar approach in this article by proposing a mildly context-sensitive formalism that can deal with scrambling up to some fixed complexity limit n that can be chosen arbitrarily high.
All these TAG variants are interesting with respect to scrambling, and they give a great deal of insight into what kind of structures are needed for scrambling.
But as explained above, none of them is entirely satisfying.
The most convincing one is VTAG, since this formalism can deal with scrambling, lexicalized V-TAG is polynomially parsable, and the set of languages V-TAG generates contains the set of all tree-adjoining languages (TALs) (in particular, the copy language).
Furthermore, a large range of word order phenomena has been treated with V-TAG, and thereby the usefulness of V-TAG for linguistic applications has been shown.
But as already mentioned, V-TAG has the inconvenience of being a nonlocal formalism.
For the reasons explained above, it is desireable to find a local TAG extension for scrambling (as opposed to the nonlocality of derivations in V-TAG, DSG, and nonlocal MCTAG) such that locality constraints for movements follow only from the form of the elementary structures and from the local character of derivations.
This article proposes a local TAG variant that can deal with scrambling (at least with an arbitrarily large set of scrambling phenomena), that is polynomially parsable, and that properly extends TAG in the sense that the set of all TALs is a proper subset of the languages it generates.
In section 2, tree-local MCTAG with shared nodes (SN-MCTAG) and in particular restricted SN-MCTAG (RSN-MCTAG) are introduced, formalisms that extend TAG in the sense mentioned above.
Section 3 shows linguistic applications of RSN-MCTAG, in particular, an analysis of scrambling.
In section 4, a relation between RSN-MCTAG and range concatenation grammar (RCG) (Boullier 1999, 2000) is established.
This relation allows us to show that certain subclasses of RSN-MCTAG are mildly context-sensitive and therefore in particular polynomially parsable.
These subclasses do not cover all cases of long-distance scrambling but, in contrast to TAG, they cover an arbitrarily large 4 More precisely, only the root of the new elementary tree and eventually (i.e., in the case of an adjunction) the foot node get identified with the node the new tree attaches to.
But there is no unification of whole subtrees.
Consequently, every edge occurring in the derived tree comes from exactly one edge in an elementary tree, and every edge from the elementary trees used in the derivation occurs exactly once in the derived tree.
In this sense the operation is resource-sensitive.
192 Kallmeyer Multicomponent TAGs with Shared Nodes set, providing scrambling analyses that respect the CETM.
This means that the limit they impose on the complexity of the scrambling data one can analyze is variable.
Based on empirical studies, it can be chosen sufficiently great such that the grammar covers all scrambling cases that one assumes to occur.
2. The Formalism An informal introduction of (restricted) tree-local MCTAG with shared nodes can also be found in Kallmeyer and Yoon (2004).
2.1 Motivation: The Idea of Shared Nodes Let us consider again example (1) in order to illustrate the general idea of shared nodes.
In standard TAG, nodes to which new elementary trees are adjoined or substituted disappear; that is, they are replaced by the new elementary tree.
For example, after having performed the derivation steps shown in Figure 2, the root node of the reparieren tree does not exist any longer.
It is replaced by the verspricht tree, and its daughters have become daughters of the foot node of the verspricht tree.
That is, the root node of the derived tree is considered to belong only to the verspricht tree.
Therefore, an adjunction at that node is an adjunction at the verspricht tree.
However, this standard TAG view is not completely justified: In the derived tree, the root node and the lower S node might as well be considered to belong to reparieren, since they are results of identifying the root node of reparieren with the root and the foot node of verspricht.
5 Therefore, we propose that the two nodes in question belong to both verspricht and reparieren.
In other words, these nodes are shared by the two elementary trees.
Consequently, they can be used to add new elementary trees to verspricht and (in contrast to standard TAG) also to reparieren.
In the following, we use an MCTAG, and we assume tree-locality; that is, the nodes to which the trees of such a set are added must all belong to the same elementary tree.
Standard tree-local MCTAGs are weakly and even strongly equivalent to TAGs, but they allow us to generate a richer set of derivation structures.
In combination with shared nodes, tree-local multicomponent derivation extends the weak generative power of the grammar (see Figure 4 for a sample tree-local MCTAG with shared nodes that generates a language that is not a tree-adjoining language).
6 Let
us go back to example (1).
Assume the tree set in Figure 3 for the scrambled NP es.
If the idea of shared nodes is adopted, this tree set can be added to reparieren using the root of the derived tree for adjunction of the first tree and the NP acc substitution node for substitution of the second tree.
The operation is tree-local, since both nodes are part of the reparieren tree.
5 Actually, in a feature-structure based TAG (FTAG) (Vijay-Shanker and Joshi 1988), the top feature structure of the root of the derived tree is the unification of the top of the root of verspricht and the top of the root of reparieren.
The bottom feature structure of the lower S node is the unification of the bottom of the foot of verspricht and the bottom of the root of reparieren.
In this sense, the root of the reparieren tree gets split into two parts.
The upper part merges with the root node of the verspricht tree, and the lower part merges with the foot node of the verspricht tree.
6 In
a way, the idea of node sharing is already present in description-based definitions of TAG-related formalisms (see Vijay-Shanker 1992; Rogers 1994; Kallmeyer 2001).
This is why these formalisms are monotonic with respect to the node properties described in the tree descriptions.
However, the possibility of exploiting this in order to obtain multiple adjunctions combined with multicomponent tree descriptions has not been pursued so far.
193 Computational Linguistics Volume 31, Number 2 Figure 3 Derivation of (1) dass es der Mechaniker zu reparieren verspricht (‘that the mechanic promises to repair it’) using shared nodes.
The notion of shared nodes means in particular that a node can be used for more than one adjunction.
(E.g., in Figure 3, two trees were adjoined at the root of the reparieren tree).
A similar idea has led to the definition of extended derivation in Schabes and Shieber (1994).
For certain auxiliary trees, Schabes and Shieber allow more than one adjunction at the same node.
However, the definition of the derived tree in Schabes and Shieber (1994) is such that if first β 1 and then β 2 are adjoined at some node µ (i.e., in the derivation tree there are edges from some γ to β 1 and β 2, both with the position p of the node µ in γ), then first the whole tree derived from β 1 is added to position p, and afterwards the whole tree derived from β 2 is added to position p.
In other words, before β 2 is adjoined, all the trees to be added by adjunction or substitution to β 1 must be added.
This is different in the case of shared nodes: After β 1 and then β 2 have been adjoined, the root node of β 2 in the derived tree is shared by β 1 and β 2 and consequently can be used for adjunctions at β 1 . 7 In other words, trees to be adjoined at the roots of β 1 and β 2 can be adjoined in any order.
This is important for obtaining all the possible permutations of scrambled elements.
2.2 Formal
Definition of Tree-Local MCTAG with Shared Nodes As already mentioned, the idea of tree-local MCTAG with shared nodes is the following: In the case of a substitution of an elementary tree α into an elementary tree γ,in the resulting tree, the root node of the subtree α is considered to be part of α and of γ.
Similarly, when an elementary tree β is adjoined at a node that is part of the elementary trees γ 1,...,γ n, then in the resulting tree, the root and foot node of β are both considered to be part of γ 1,...,γ n and β.
Consequently, if an elementary tree γ prime is added to an elementary tree γ, and if there is then a sequence of adjunctions at root 7 In this case, one obtains crossed dotted edges in the SN-derivation structure defined later (see Figure 14 for an example).
194 Kallmeyer Multicomponent TAGs with Shared Nodes or foot nodes starting from γ prime, then each of these adjunctions can be considered an adjunction at γ, since it takes place at a node shared by γ,γ prime, and all the subsequently adjoined trees.
Therefore, one way to define SN-MCTAG refers to the standard TAG derivation tree in the following way.
Define the grammar as an MCTAG and then allow only derivation trees that satisfy the following tree-locality condition: For each instance {γ 1,...,γ k } of an elementary tree set in the derivation tree, there is a γ such that each of the γ i is either a daughter of γ or is linked to one of the daughters of γ by a chain of adjunctions at root or foot nodes.
As an example, consider the derivation tree for (1) in Figure 3.
It shows that the trees used in the derivation are the reparieren tree, the verspricht tree, the Mechaniker tree, and the two trees es and epsilon1-es from the tree set in Figure 3.
epsilon1-es is substituted into reparieren at position 21, and verspricht is adjoined to reparieren at position epsilon1.
Then, Mechaniker is substituted into verspricht at position 1, and es is adjoined to verspricht at position epsilon1.The derivation is tree-local in the node-sharing sense, since for the tree set {epsilon1-es, es}, epsilon1-es is a daughter of reparieren in the derivation tree and es is linked to reparieren byafirst adjunction of verspricht to reparieren and a further adjunction of es to the root of verspricht.
In the following, we adopt this way of viewing derivations in SN-MCTAG as specific multicomponent TAG derivations; that is, we define SN-MCTAG as a variant of MCTAG.
This avoids formalizing a notion of shared nodes, even though this was the starting motivation for the formalism.
We assume a definition of TAG as a tuple G =〈I, A, N, T〉 with I being the set of initial trees, A the set of auxiliary trees, and N and T the nonterminal and terminal node labels, respectively (see, for example, Vijay-Shanker [1987] for a formal definition of TAG).
Now we formally introduce multicomponent tree-adjoining grammars (Joshi 1987; Weir 1988): Definition 1 A multicomponent tree-adjoining grammar is a tuple G =〈I, A, N, T,A〉 such that a114 G TAG :=〈I, A, N, T〉 is a TAG; a114 A ⊆ P(I ∪ A)isasetofsubsetsofI ∪ A, the set of elementary tree sets.
8 γ ⇒ γ prime is a multicomponent derivation step in G iff there is an instanceγ 1,...,γ n } of an elementary tree set in A and there are pairwise different node addresses p 1,..., p n such that γ prime = γ[p 1,γ 1 ]...[p n,γ n ], where γ[p 1,γ 1 ]...[p n,γ n ] is the result of adding the γ i (1 ≤ i ≤ n) at node positions p i in γ.
9 As
in TAG, a derivation starts from an initial tree, and in the end, in the final derived tree, there must not be any obligatory adjunction constraint, and all leaves must be labeled by a terminal or by the empty word.
In each MCTAG derivation step, an elementary tree set is chosen, and the trees from this set are added to the already derived tree.
Since they are added to pairwise different 8 P(X) is the set of subsets of some set X.
9 As
usual (see Vijay-Shanker 1987; Weir 1988), γ[p,γ prime ] is defined as follows: If γ prime is (derived from) an initial tree and the node at position p in γ is a substitution node, then γ[p,γ prime ] is the tree one obtains by substitution of γ prime into γ at node position p.Ifγ prime is (derived from) an auxiliary tree and the node at position p in γ is an internal node, then γ[p,γ prime ] is the tree one obtains by adjunction of γ prime to γ at node position p.Otherwiseγ[p,γ prime ] is undefined.
195 Computational Linguistics Volume 31, Number 2 nodes, one can just as well add them one after the other; that is, each multicomponent derivation in an MCTAG G =〈I, A, N, T,A〉 corresponds to a derivation in the TAG G TAG :=〈I, A, N, T〉.
Let us define the TAG derivation tree of such a multicomponent derivation as the corresponding derivation tree in G TAG . We can then define tree-local, set-local, and nonlocal MCTAG and also the different variants of SN-MCTAG this article deals with by putting different constraints on this derivation tree.
10 Note
that for each operation γ[p,γ i ],thenodeaddressp in the derived tree γ points at a node that is at some address p prime in some elementary tree γ prime that was already added (γ prime and p prime are unique).
In the TAG derivation tree, there will be in this case an edge from γ prime to γ i with position p prime . A TAG derivation tree can be considered a tuple of nodes and edges.
As usual in finite trees, the edges are directed from the mother node to the daughter.
Linear precedence is not needed in a derivation tree, since it does not influence the result of the derivation.
So a derivation tree is a tuple 〈N,E〉,withN being a finite set of instances of elementary trees and with E ⊂ N ×N × IN ∗, where IN ∗ is the set of Gorn addresses.
We define the parent relation as the relation between mothers and daughters in a derivation tree, the dominance relation as the reflexive transitive closure of the parent relation, and the node-sharing relation as the relation between nodes that either are mother and daughter or are linked first by a substitution/adjunction and then a chain of adjunctions at root or foot nodes: Definition 2 Let D =〈N,E〉 be a derivation tree in a TAG.
a114 P D :={〈n 1, n 2 〉|n 1, n 2 ∈ N, and there is a p ∈ IN ∗ such that 〈n 1, n 2, p〉∈E} is the parent relation in D.
a114 D D :={〈n 1, n 2 〉|n 1, n 2 ∈ N, and either n 1 = n 2, or there is a n 3 such that 〈n 1, n 3 〉∈P D and 〈n 3, n 2 〉∈D D } is the dominance relation in D.
a114 SN D :={〈n 1, n 2 〉| either 〈n 1, n 2 〉∈P D or there are t 1,..., t k ∈ N, such that 〈n 1, t 1 〉∈P D, n 2 = t k and for all j,1≤ j ≤ k − 1: 〈t i, t i+1, p prime 〉∈E with either p prime = epsilon1 or t i being an auxiliary tree with foot node address p prime } is the node-sharing relation in D.
A node-sharing relation 〈γ 1,γ 2 〉 that corresponds to an actual parent relation is called a primary node-sharing relation, and γ 2 is called a primary SN-daughter of γ 1, whereas any other node-sharing relation 〈γ 1,γ 2 〉 is called secondary and in this case γ 2 is called a secondary SN-daughter of γ 1 . The TAG derivation trees for MCTAG derivations have certain properties resulting from the requirement that the elements of instances of elementary tree sets must be added simultaneously to the already derived tree: First, if an elementary tree set is used, then all trees from this set must occur in the derivation tree.
Secondly, one tree from an elementary tree set cannot be substituted or adjoined into another tree from the same set, and, thirdly, two tree sets cannot be interleaved.
For nonlocal MCTAG, these are all constraints the TAG derivation tree needs to satisfy.
10 This
TAG derivation tree is not the MCTAG derivation tree defined in Weir (1988).
The nodes of Weir’s MCTAG derivation trees are labeled by sequences of elementary trees (i.e., by elementary tree sets), and each edge stands for simultaneous adjunctions/substitutions of all elements of such a set.
196 Kallmeyer Multicomponent TAGs with Shared Nodes Lemma 1 Let G =〈I, A, N, T,A〉 be an MCTAG, G TAG :=〈I, A, N, T〉.LetD =〈N,E〉 be a derivation tree in G TAG with the corresponding derived tree t being in L(G TAG ).
D is a possible TAG derivation tree in G with t ∈ L(G)iffD is such that a114 (MC1) The root of D is an instance of an initial tree α ∈ I and all other nodes are instances of trees from tree sets in A such that for all instances Γ of elementary tree sets from A and for all γ 1,γ 2 ∈Γ,ifγ 1 ∈ N, then γ 2 ∈ N.
a114 (MC2) For all instances Γ of elementary tree sets from A and for all γ 1,γ 2 ∈Γ, γ 1 negationslash= γ 2 : 〈γ 1,γ 2 〉 negationslash∈ D D . a114 (MC3) For all pairwise different instances Γ 1,Γ 2,...,Γ n, n ≥ 2, of elementary tree sets from A, there are no γ (i) 1,γ (i) 2 ∈Γ i,1≥ i ≥ n, such that 〈γ (1) 1,γ (n) 2 〉∈D D and 〈γ (i) 1,γ (i−1) 2 〉∈D D for 2 ≥ i ≥ n.
The proof of this lemma is given in the appendix.
The lemma gives us a way to characterize nonlocal MCTAG via the properties of the TAG derivation trees the grammar licenses.
With this characterization we get rid of the original simultaneity requirement: The corresponding properties are now captured in the three constraints (MC1)–(MC3).
But since these constraints need to hold only for the TAG derivation trees that correspond to derived trees in the tree language, subderivation trees need not satisfy them.
In other words, γ 1 and γ 2 from the same elementary tree set can be added at different moments of the derivation as long as the final complete TAG derivation tree satisfies (MC1)–(MC3).
We now define tree-local, set-local, SN-tree-local, and SN-set-local TAG derivation trees by imposing further conditions.
Basically, the difference between the first two and their SN variants is that in the first two, the definition refers to the parent relation, whereas in the second two, it refers to the node-sharing relation.
Definition 3 Let G =〈I, A, N, T,A〉 be an MCTAG.
Let D =〈N,E〉 be a TAG derivation tree for some t ∈ L(〈I, A, N, T〉).
a114 D is a multicomponent derivation tree iff it satisfies (MC1)–(MC3).
a114 D is tree-local iff for all instances {γ 1,...,γ n } of elementary tree sets with γ 1,...,γ n ∈ N, there is one γ such that 〈γ,γ 1 〉,...,〈γ,γ n 〉∈P D . a114 D is set-local iff for all instances {γ 1,...,γ n } of elementary tree sets with γ 1,...,γ n ∈ N, there is an instance Γ of an elementary tree set such that for all 1 ≤ i ≤ n, there is a t i ∈Γ with 〈t i,γ i 〉∈P D . a114 D is SN-tree-local iff for all instances {γ 1,...,γ n } of elementary tree sets with γ 1,...,γ n ∈ N, there is one γ such that 〈γ,γ 1 〉,...,〈γ,γ n 〉 ∈ SN D . a114 D is SN-set-local iff for all instances {γ 1,...,γ n } of elementary tree sets with γ 1,...,γ n ∈ N, there is an instance Γ of an elementary tree set such that for all 1 ≤ i ≤ n, there is a t i ∈Γ with 〈t i,γ i 〉∈SN D . 197 Computational Linguistics Volume 31, Number 2 Figure 4 SN-MCTAG for {w 3 |w ∈ T ∗ }.
The formalism we are proposing for scrambling is MCTAG with SN-tree-local TAG derivation trees.
We call these grammars tree-local MCTAGs with shared nodes: Definition 4 Let G be an MCTAG.
G is a tree-local MCTAG with shared nodes iff the set of trees generated by G, L T (G), is defined as the set of those trees that can be derived with an SN-tree-local multicomponent TAG derivation tree in G.
As usual, the string language L S (G) is then defined as the set of strings yielded by the trees in L T (G).
All tree-adjoining languages can be generated by SN-MCTAGs, since a TAG corresponds to an MCTAG with unary multicomponent sets.
For such an MCTAG, each TAG derivation tree is trivially SN-tree-local.
In other words, in this case the tree sets are the same, whether the grammar is considered a TAG, a tree-local MCTAG, or an SN-MCTAG.
11 In
particular, all TAG analyses proposed so far can be maintained, since each TAG is trivially also an instance of SN-MCTAG.
SN-MCTAG is a proper extension of TAG (and of tree-local MCTAG) in the sense that there are languages that can be generated by an SN-MCTAG but not by a TAG.
As an example, consider Figure 4, which shows an SN-MCTAG for {www|w ∈ T ∗ }.
12 Similar
to the grammar in Figure 4, for all copy languages {w n |w ∈ T ∗ } for some n ∈ IN, an SN-MCTAG can be found.
Other languages that can be generated by SN-MCTAG and that are not TALs are the counting languages {a n 1 ...a n k |n ≥ 1} for any k > 4(for k ≤ 4, these languages are tree-adjoining languages).
There are two crucial differences between V-TAG and SN-MCTAG: First, in VTAG, the adjunctions of auxiliary trees from the same set need not be simultaneous.
In this respect, V-TAG differs not only from SN-MCTAG, but from any of the different 11 However, viewing a TAG as an SN-MCTAG allows us to obtain a richer set of SN-derivation structures, as introduced in the next section.
This is exploited in Kallmeyer (2002) for semantics.
12 The
subscript NA in the figure stands for null adjunction; that is, it disallows adjunctions at the node in question.
198 Kallmeyer Multicomponent TAGs with Shared Nodes MCTAGs mentioned above.
Secondly, V-TAG is nonlocal in the sense of nonlocal MCTAG, whereas SN-MCTAG is local, even though the locality is not based on the parent relation in the derivation tree, as is the case in standard local MCTAG, but on the SNdominance relation in the derivation tree.
As a consequence of the locality, we do not need dominance links (i.e., dominance constraints that have to be satisfied by the derived tree) in SN-MCTAG, in contrast to other TAG variants for scrambling.
The locality condition put on the derivation sufficiently constrains the possibilities for attaching the trees from elementary tree sets: Different trees from a tree set attach to different nodes of the same elementary tree.
Consequently, the dominance relations among these different nodes determine the dominance relations among the different trees from the tree set.
Therefore extra dominance links are not necessary.
This is different for nonlocal TAG variants such as V-TAG or DSG, in which one can in principle attach the different components of an elementary structure at arbitrary nodes in the derived tree.
2.3 SN-MCTAG and Scrambling: Formal Considerations Figure 5 shows an SN-MCTAG generating a language that cannot even be generated by linear context-free rewriting systems (see Becker, Rambow, and Niv [1992] for a proof), and therefore not by set-local MCTAG.
This example, however, concerns neither weak nor strong generative capacity, but something that Becker, Rambow, and Niv (1992) call derivational capacity: the derivation of n k v k must be such that the π(i)th n and the ith v come from the same elementary tree set in the grammar.
The grammar in Figure 5 works in the following way: Each derivation starts with α.
Then a first instance of the tree set (yielding n 1 and v 1 ) is added to the N and V nodes in α.
For each further instance of the tree set (yielding n i and v i ), β v is adjoined to the root node of the β v tree of v i−1 . Therefore all β v adjunctions except the first are occurring at root nodes, and consequently all β v are (primary or secondary) SN-daughters of α.
The β n tree of n i can be adjoined to any of the root or foot nodes of the β n that have already been added, since in this way all adjunctions of β n except the first one occur at root or foot nodes, and therefore all these β n are SN-daughters of α.
This allows us to place n i at any position in the string already containing {n 1,..., n i−1 }, and thereby any permutation of the ns can be obtained.
Since all nodes in the derivation tree are SNdaughters of α, the derivation is SN-tree-local.
Note that in the grammar in Figure 5, there is no NA constraint on the foot node of the first auxiliary tree in the tree set.
This is crucial for allowing all permutations of the n 1,..., n k . In this respect, the elementary trees differ from what is usually done in TAG.
Becker, Rambow, and Niv (1992) argue that a formalism that cannot generate the language in Figure 5 is not able to analyze scrambling in an adequate way.
We think, Figure 5 SN-MCTAG for {n π(k) ...n π(1) v k ...v 1 |k ≥ 0, n i = n, v i = v,andn i and v i are in the same elementary tree set and they were added in the ith derivation step for all i,1≤ i ≤ k,andπ is a permutation of (1,..., k)}.
199 Computational Linguistics Volume 31, Number 2 Figure 6 Predicate argument structure for SCR.
however, that this language is not exactly what one needs for scrambling.
The assumption underlying the language in Figure 5 is that n i is an argument of v i . But in this case, instead of adding n i and v i at the same time, n i should be added to v i . If one makes the additional assumption that argument NPs are added by substitution, then one can require that the argument NPs have already been substituted (this is what Joshi, Becker, and Rambow [2000] call the weak co-occurrence constraint), that is, that the tree for v i contain n i . In this case, the language in Figure 5 is an appropriate test language for scrambling.
But we do not want to make this assumption.
Furthermore, there are more predicate-argument dependencies: v i is also an argument of v i−1 for i ≤ 2.
This is what Joshi, Becker, and Rambow (2000) call the strong co-occurrence constraint.
In other words, the dependency tree should be as in Figure 6.
Additionally to the permutation of the n 1,..., n k,alsothev i can be moved leftward, as long as they do not permute among themselves.
Consequently, for scrambling data (without extraposition), one rather wants to generate the following language: SCR := {w = π(n 1 ...n k v 1 ...v k )|k ≥ 1, n i = n, v i = v, for all 1 ≤ i ≤ k,andπ is a permutation of n 1 ...n k v 1 ...v k such that n i precedes v i in w for all 1 ≤ i ≤ k and v i precedes v i−1 in w for all 1 < i ≤ k} with the derivation structure in Figure 6.
An SN-MCTAG generating this language is shown in Figure 7.
The SN-MCTAG in Figure 7 yields the following derivations: Either start with α 2,in which case an instance of {β n,α n } must be added and nv is obtained with n depending on v, or start with α 1 for v 1, in which case, for all v except the leftmost one, the set {β v1,α v 1 } is added, for the leftmost v,asetβ v2,α v2 } is added, and for all the ns, sets {β n,α n } are added.
These sets can be added in any order; the auxiliary tree is always adjoined to the root node of the already derived tree that is shared by all auxiliary trees that have been used so far and by the first α 1 . The initial tree is primarily substituted Figure 7 SN-MCTAG for SCR.
200 Kallmeyer Multicomponent TAGs with Shared Nodes into the argument slot it fills.
So the only condition for adding such a tree set is that the verb it depends on has already been added, since the tree of this verb provides the substitution node for the initial tree.
Therefore, since the lexical material is always left of the foot node, one obtains that v i precedes v i−1 for all 1 < i ≤ k and n i precedes v i for all 1 ≤ i ≤ k.
Note that in Figure 7, for a scrambled n i, the substitution node is filled with an empty node, while the n is adjoined higher at a node that is not yet available in the elementary structure of v i . So the combination of n i and v i cannot be precompiled here.
2.4 Restricted
SN-MCTAG When the formal properties of SN-MCTAG are examined, it becomes clear that the formalism is hard to compare to other local TAG-related formalisms, since in the derivation tree, arbitrarily many trees can be secondary SN-daughters of a single elementary tree, such that these secondary links are considered to be adjunctions to that tree.
This means that these secondary links are relevant for the SN-tree-locality of the derivation.
An example is the grammar in Figure 5, in which in each derivation step, the relevant nodesharing relations are the links between α and the two auxiliary trees of the new set.
This means that for a word of length k, there are k SN-daughters of α that are relevant for the SN-tree-locality of the derivation.
The grammar in Figure 5 indicates that this property of SN-MCTAG is at least partly responsible for the fact that SN-MCTAG allows us to generate languages that are not even mildly context-sensitive (i.e., that are not in the class of languages that can be generated by LCFRS).
However, it would be desirable to stay inside the class of mildly context-sensitive languages.
Therefore, in the following, we define a restricted version, RSN-MCTAG, that limits the number of relevant secondary SN-daughters of an elementary tree.
The restriction is obtained as follows: We require that in each derivation step, among the SN-relations between the old γ and the new set Γ, there be at least one primary SN-relation.
The number of primary SN-daughters of a specific elementary tree is limited, since the primary SN-daughters correspond to substitutions/adjunctions at pairwise different nodes and the number of nodes in an elementary tree is limited.
Consequently, the number of relevant secondary SN-daughters for a node is limited as well.
An example of a derivation satisfying the new constraint is that in Figure 3, in which es is a secondary SN-daughter of reparieren, while the second element of the tree set, epsilon1-es, is a primary SN-daughter of reparieren.
Definition 5 a114 Let G =〈I, A, N, T,A〉 be an MCTAG.
Let D =〈N,E〉 be the TAG derivation tree of a tree t ∈ L T (〈I, A, N, T〉).
D is RSN-tree-local iff for all instances {γ 1,...,γ n } of an elementary tree set with γ 1,...,γ n ∈ N, there is one γ such that 1.
〈γ,γ 1 〉,...,〈γ,γ n 〉∈SN D ; 2.
there is one i,1≤ i ≤ n,with〈γ,γ i 〉∈P D . a114 An MCTAG G is called a restricted SN-MCTAG iff the set of trees generated by G, L T (G), is defined as the set of those trees that can be derived with an RSN-tree-local multicomponent TAG derivation tree in G.
201 Computational Linguistics Volume 31, Number 2 The first condition of the definition says that the grammar is SN-tree-local, and the second condition ensures that at least one of the relevant SN-daughters of γ is a primary SN-daughter, that is, an actual daughter of γ.
As for SN-MCTAG, all tree-adjoining languages can also be generated by RSNMCTAGs.
The sample grammars in Figures 4 and 5 are not RSN-MCTAGs.
We suspect that there is no RSN-MCTAG that generates the language in Figure 5.
But the grammar in Figure 7 for the language SCR is an RSN-MCTAG.
It can be shown that for the TAG derivation trees of an RSN-MCTAG, the following holds: For each instance of an elementary tree set Γ,theγ to which all elements of Γ are linked by node-sharing relations with at least one primary link is unique (which is not necessarily the case for general SN-MCTAG).
This is formulated in the following lemma: Lemma 2 Let G =〈I, A, N, T,A〉 be an RSN-MCTAG.
Let D =〈N,E〉 be a TAG derivation tree in G.
Then for all instances {γ 1,...,γ n } of elementary tree sets with γ 1,...,γ n ∈ N, there is exactly one γ such that 〈γ,γ 1 〉,...,〈γ,γ n 〉∈SN D, and there is one i,1≤ i ≤ n,with 〈γ,γ i 〉∈P D . For such an elementary tree set {γ 1,...,γ n },withγ being the unique elementary tree as described in the lemma, all 〈γ,γ i 〉∈SN D \P D,1≤ i ≤ n, are called secondary adjunction links in D.
The proof of the lemma is given in the appendix.
Now we introduce the SN-derivation structure of a TAG derivation tree D in an RSN-MCTAG.
It consists of D enriched with additional links for the secondary adjunctions.
These links are equipped with the positions of the first substitutions/adjunctions on the chain that corresponds to the secondary adjunctions.
Definition 6 Let G =〈I, A, N, T,A〉 be an RSN-MCTAG.
Let D =〈N,E〉 be a TAG derivation tree in G.TheSN-derivation structure of D, D SN, is then D SN :=〈N,E prime 〉, with E ⊆ E prime . a114 For all secondary adjunction links 〈γ 1,γ 2 〉 in D with γ prime and p such that 〈γ 1,γ prime, p〉∈E and 〈γ prime,γ 2 〉∈D D : 〈γ 1,γ 2, p〉∈E prime . a114 These are all elements of E prime . All e ∈ E are called primary edges in D SN,andalle ∈ E prime \E are called secondary edges in D SN . With the notion of the SN-derivation structure, we can formulate the limitation on the maximal number of secondary adjunctions to an elementary tree that we mentioned at the beginning of this section: Lemma 3 Let G =〈I, A, N, T,A〉 be an RSN-MCTAG.
Then there is a constant c such that for all TAG derivation trees D in G with SN-derivation structure D SN :=〈N,E〉, the following holds: 202 Kallmeyer Multicomponent TAGs with Shared Nodes There is no n ∈ N such that there exist m ≥ c + 1 pairwise different n 1,..., n m such that for all i,1≤ i ≤ m, there is a p such that a114 either 〈n, n i, p〉 is a secondary edge in D SN ; a114 or 〈n, n i, p〉 is a primary edge in D SN, and there are no n prime and p prime such that 〈n prime, n i, p prime 〉 is a secondary edge in D SN . That this lemma holds is nearly immediate: Each secondary adjunction must be associated with a primary adjunction or substitution into the same tree instance.
There are at most k primary adjunctions or substitutions into any tree instance if k is the maximal number of nodes per elementary tree.
Consequently there are at most k × n secondary adjunctions per node if n + 1 is the maximal number of trees per elementary tree set.
In linguistic applications, the SN-derivation structure is intended to reflect the predicate-argument dependencies of a sentence in the following way: For each tree in the SN-derivation structure, if this tree is secondarily adjoined to some other tree γ, then it depends on γ.
Otherwise it depends on its mother node in the TAG derivation tree.
In this way, the grammar for SCR in Figure 7 yields the desired dependency structure.
3. Linguistic Applications 3.1 Scrambling with RSN-MCTAG In this section, we present a small German grammar that allows us to analyze some cases of scrambling.
The aim is not an exhaustive treatment of the phenomenon, but just to show that in principle, an analysis of scrambling in German is possible using RSN-MCTAG.
The data to which we restrict ourselves are word order variations of example (3) without extraposition, that is, under the assumption that the order of the verbs is zu reparieren zu versuchen verspricht: (3) ...dass er dem Kunden das Fahrrad zu reparieren ...thathe nom the customer dat the bike acc to repair zu versuchen verspricht to try promises ‘...thathepromisesthecustomertotrytorepairthebike’ The elementary trees and tree sets for example (3) are shown in Figure 8.
In contrast to standard TAG practices, which are often guided by technical considerations, we represent all arguments of a verb (including an embedded VP) by substitution nodes.
For those parts that might be scrambled, there is a single elementary tree (for the case without scrambling) and a tree set used for scrambling.
The tree set contains an auxiliary tree that can be primarily or secondarily adjoined to some root node and a tree with the empty word that is intended to fill the argument position.
In order to avoid spurious ambiguities, we assume that whenever a derivation using the single elementary tree is possible, this is chosen.
A scrambled element always adjoins to a VP node, and the scrambled element is to the left of the foot node.
Therefore it precedes everything that is below or on the 203 Computational Linguistics Volume 31, Number 2 Figure 8 Elementary trees for scrambling.
right of the VP node to which it adjoins.
Consequently, given the form of the verbal elementary trees in Figure 8, in which the verb is always below or to the right of all VP nodes allowing adjunction, the order xvfor an x being a nominal or a verbal argument of v is always respected.
For an element (a lexical item), the tree set for scrambling is used whenever one of the following three cases holds: a114 The element is scrambled.
a114 Scrambling of depth more than one out of the element takes place.
a114 The element intervenes between some element A (on its right) and some element B (on its left) scrambled out of A, and the element itself does not belong to A.
In other words, the fact that the set for scrambling is used for some element does not necessarily mean that this element is scrambled.
It just means that one of the three cases above holds, that is, that some scrambling around this element takes place.
One could actually do without the single trees and always use the tree sets.
In this case, even if no scrambling took place, all argument slots would be filled by empty words, and all lexical material would be adjoined to the root node of the derived tree.
At first glance, this seems rather odd.
But if one does not consider the substitution nodes argument slots but rather some kind of subcategorization features marking which arguments need to be added, an analysis using only the tree sets makes sense.
However, for this article, we keep the single trees.
For example (3), a derivation without secondary adjunctions and using only the single trees is possible.
Let us consider the following word orders as examples of how secondary adjunction is used for scrambling: 204 Kallmeyer Multicomponent TAGs with Shared Nodes (4) ...dass er 1 [[das Fahrrad zu reparieren] zu versuchen] 2 t 1 dem Kunden t 2 ...thathe thebike torepair totry thecustomer verspricht promises (5) ...dass er [das Fahrrad zu reparieren] 1 dem Kunden [t 1 zu versuchen] ...thathethebike torepair thecustomer totry verspricht promises (6) ...dass [das Fahrrad] 1 er 2 [[t 1 zu reparieren] zu versuchen] 3 t 2 dem Kunden t 3 ...thatthebike he torepair totry thecustomer verspricht promises In example (4), the versuchen-VP and er are scrambled.
13 Consequently, for versuchen and er, the sets with two trees are used, whereas for all the other elements, the single trees can be used.
In example (5), the reparieren-VP is scrambled out of the versuchen-VP, with dem Kunden intervening between the two.
Therefore, the tree sets are used for reparieren and dem Kunden.
For versuchen, the single tree can be used, since the scrambling out of versuchen is of depth one.
In example (6), we have the same scrambling as in example (4), and additionally, das Fahrrad is scrambled out of the reparieren-VP and the versuchen-VP (depth two).
Consequently, in this case one needs tree sets for Fahrrad, er, versuchen,and reparieren.
Let us consider the analysis of example (4): Starting with verspricht, the single tree for dem Kunden and the tree set for versuchen (with adjunction of the auxiliary tree at the root) are added.
This leads to the first tree in Figure 9.
The VP nodes in boldface type in the figure are shared by versuchen and verspricht; that is, they can be used for further adjunction at the verspricht tree.
(Of course, only the root node can be used for adjunction, since the other nodes have NA constraints).
It does not matter in which order er and zu reparieren are added.
For er, the tree set is used.
The auxiliary tree is secondarily adjoined to the root node, and the initial tree is substituted for the NP nom node in the verspricht tree.
This leads to the second tree in Figure 9.
For reparieren and das Fahrrad, the single trees are added below the VP substitution node in the versuchen tree.
The corresponding SN-derivation structure (see Figure 9) contains the desired predicateargument dependencies.
The TAG derivation tree is RSN-tree-local.
Next, let us consider example (5).
Here, the single trees for er and versuchen are added to verspricht.
This leads to the first tree in Figure 10.
The VP node in boldface type in the figure belongs to verspricht and versuchen.
It is next used for secondary adjunction of dem Kunden to the verspricht tree.
The initial tree is substituted at the NP dat slot.
This leads to the second tree.
Here, the bold VP node belongs to verspricht, versuchen,and Kunde.
It is next used for secondary adjunction of the auxiliary tree of reparieren to versuchen, while the initial tree is substituted for the VP leaf in the versuchen tree.
This 13 Actually, er here is not really scrambled, but since in our formalism, scrambled elements attach at the left of a VP, any other element even more to the left is treated as if it is scrambled (even if it depends on the matrix verb).
205 Computational Linguistics Volume 31, Number 2 Figure 9 Analysis of example (4).
Figure 10 Analysis of example (5).
leads to the third tree.
After that, one needs only to add the single tree for das Fahrrad to reparieren.
Note that this is a derivation in which the foot node of the elementary tree containing the lexical material does not dominate the tree with the empty word.
Now let us consider the derivation of example (6).
Here, only for dem Kunden,the single tree is added by substitution.
In all other cases, the tree set is used with (primary 206 Kallmeyer Multicomponent TAGs with Shared Nodes or secondary) adjunction at the root node of the already derived tree.
This root node consequently belongs to all verbs that have already occurred in the derivation and can therefore be used to add arguments to any of them.
We leave it to the reader to verify that all word orders can be generated.
This kind of analysis also works for more than two embeddings.
Since all scrambled elements attach to a VP node in the elementary tree of the verb they depend on, they cannot attach to the VP of a higher finite verb that embeds the sentence in which the scrambling occurs.
In this way, a barrier effect is obtained without establishing any explicit barrier, as is done in V-TAG.
Instead, this locality of scrambling is a consequence of the form of the elementary trees and of the locality of the derivations.
Concerning adjunct scrambling, each adjunct has a single auxiliary tree as in standard TAG and additionally a set of two auxiliary trees, a lower auxiliary tree with an empty word and a higher auxiliary tree with the adjunct.
This is shown in Figure 11.
The internal VP node of the higher tree in the tree set serves as an adjunction site for the lower parts of other adjuncts.
Similarly, the elementary trees of verbs need an extra VP node in order to adjoin adverbs.
For more analyses of scrambling, including scrambling in combination with extraposition and topicalization, and also for an extension of the analysis presented here to Korean data, see Kallmeyer and Yoon (2004).
3.2 Raising
Verbs and Subject-Auxiliary Inversion Other phenomena often mentioned in the TAG literature (see, e.g., Rambow, VijayShanker, and Weir 1995; Kulick 2000; Dras, Chiang, and Schuler 2004) as being problematic for TAG and tree-local MCTAG are sentences with raising verbs and subject-auxiliary inversion, as in examples (7) and (8): (7) Does Gabriel seem to be likely to eat gnocchi?
(8) What does John seem to be certain to like?
The standard TAG analyses of examples (7) and (8) (see Figure 12 for the analysis of example (8)) start with the eat and like tree, respectively, adjoin an auxiliary tree for likely and certain, respectively, and then add the trees for does and seem, respectively.
If we assume that these trees are in the same elementary tree set, then this last derivation step is nonlocal, since the does tree adjoins to eat and like, respectively, while the seem tree adjoins to likely and certain, respectively.
Though different from scrambling, this problem seems to be of a similar nature, and formalisms that have been proposed for scrambling have also been used to treat these examples (see Kulick 2000).
RSN-MCTAG allows us to analyze examples (7) and (8) in a way that puts does and seem into a single elementary tree set: After having adjoined to be likely and to be certain, Figure 11 Trees for adjuncts.
207 Computational Linguistics Volume 31, Number 2 Figure 12 Derivation for (8).
respectively, the root nodes of the adjoined trees are considered still to be part of the elementary trees of eat and like, respectively.
These elementary trees can then be used to add the elementary tree set for does and seem: Both auxiliary trees are adjoined to these trees.
Figure 12 shows the corresponding SN-derivation structure.
4. RSN-MCTAG and Range Concatenation Grammar In the following, we show that for each RSN-MCTAG of a certain type (i.e., with an additional restriction), a weakly equivalent simple range concatenation grammar (Boullier 1999, 2000) can be constructed.
It has been shown that RCGs generate exactly the class of all polynomially parsable languages (Bertsch and Nederhof 2001; appendix A).
Furthermore, as shown in Boullier (1998b), simple RCGs in particular are even weakly equivalent to linear context-free rewriting systems (Weir 1988).
As a consequence, one obtains that the languages generated by simple RSN-MCTAGs are mildly context-sensitive.
This last property was introduced in Joshi (1985).
It includes formalisms that are polynomially parsable, are semilinear, and allow only a limited number of crossing dependencies.
(We do not give formal definitions of mild contextsensitivity and of LCFRS, since we do not need these definitions in this article.) Concerning RSN-MCTAGs in general, that is, without any further restriction, we are almost sure that they are not mildly context-sensitive.
Perhaps they can even generate languages that are not in the class of languages generated by RCGs.
4.1 Range
Concatenation Grammars This section defines range concatenation grammars.
14 Definition
7 A range concatenation grammar is a tuple G =〈N, T, V, S, P〉 such that a114 N is a finite set of predicates, each with a fixed arity; a114 T and V are disjoint finite sets of terminals and of variables; a114 S ∈ N is the start predicate, a predicate of arity 1; a114 P is a finite set clauses of the form A 0 (x 01,..., x 0a 0 ) → epsilon1, or A 0 (x 01,..., x 0a 0 ) → A 1 (x 11,..., x 1a 1 )...A n (x n1,..., x na n ), with n ≥ 1andA i ∈ N, x ij ∈ (T ∪ V) ∗ and a i being the arity of A i . 14 Since throughout the article, we use only positive RCGs; whenever we say “RCG,” we actually mean “positive RCG.” 208 Kallmeyer Multicomponent TAGs with Shared Nodes When applying a clause with respect to a string w = t 1 ···t n, the arguments of the predicates in the clause are instantiated with substrings of w, more precisely, with the corresponding ranges.
A range 〈i, j〉 with 0 ≤ i < j ≤ n corresponds to the substring between positions i and j, that is, to the substring t i+1 ···t j .Ifi = j, then 〈i, j〉 corresponds to the empty string epsilon1.Ifi > j, then 〈i, j〉 is undefined.
Definition 8 For a given clause, an instantiation with respect to a string w = t 1 ...t n consists of a function f : {t prime |t prime is an occurrence of some t ∈ T in the clause}∪V →{〈i, j〉|i ≤ j, i, j ∈ IN} such that a114 for all occurrences t prime of a t ∈ T in the clause: f (t prime ):=〈i, i + 1〉 for some i,0≤ i < n, such that t i = t; a114 for all v ∈ V: f (v) =〈j, k〉 for some 0 ≤ j ≤ k ≤ n; a114 if consecutive variables and occurrences of terminals in an argument in the clause are mapped to 〈i 1, j 1 〉,...,〈i k, j k 〉 for some k, then j m = i m+1 for 1 ≤ m < k.
By definition, we then state that f maps the whole argument to 〈i 1, j k 〉.
The derivation relation is defined as follows.
For a predicate A of arity k, a clause A()... → ..., and ranges 〈i 1, j 1 〉,...,〈i k, j k 〉 with respect to a given w: If there is an instantiation of this clause with left-hand side A(〈i 1, j 1 〉,...,〈i k, j k 〉), then A(〈i 1, j 1 〉,...,〈i i, j k 〉) can be replaced with the right-hand side of this instantiation.
The language of an RCG G is the set of strings that can be reduced to the empty word, that is, {w|S(〈0,|w|〉) ∗ ⇒ epsilon1 with respect to w}.
15 An
RCG with maximal predicate arity n is called an RCG of arity n.
For illustration, let us consider a sample RCG: The RCG with N ={S, A, B}, T ={a, b}, V ={X, Y, Z}, start predicate S, and clauses S(XYZ) → A(X, Z) B(Y), A(aX, aY) → A(X, Y), B(bX) → B(X), A(epsilon1,epsilon1) → epsilon1, B(epsilon1) → epsilon1 has the string language {a n b k a n |k, n ∈ IN}.
Consider the reduction of w = aabaa: We start from S(〈0, 5〉).
First we can apply the following clause instantiation: S(XY Z) → A(X, Z) B(Y) 〈0,2〉〈2,3〉〈3,5〉〈0,2〉〈3,5〉〈2,3〉 aa b aa aa aa b With this instantiation, S(〈0, 5〉) ⇒ A(〈0, 2〉,〈3, 5〉)B(〈2, 3〉).
Then B(bX) → B(X) 〈2,3〉〈3,3〉〈3,3〉 b epsilon1epsilon1 15 |w| is the length of the word w; that is, the range 〈0,|w|〉 with respect to w corresponds to the whole word w.
209 Computational Linguistics Volume 31, Number 2 and B(epsilon1) → epsilon1 lead to A(〈0, 2〉,〈3, 5〉)B(〈2, 3〉) ⇒ A(〈0, 2〉,〈3, 5〉)B(〈3, 3〉) ⇒ A(〈0, 2〉, 〈3, 5〉).
Next, A(aX a Y) → A(X, Y) 〈0,1〉〈1,2〉〈3,4〉〈4,5〉〈1,2〉〈4,5〉 aaaa aa leads to A(〈0, 2〉,〈3, 5〉) ⇒ A(〈1, 2〉,〈4, 5〉).
Then A(aX a Y) → A(X, Y) 〈1,2〉〈2,2〉〈4,5〉〈5,5〉〈2,2〉〈5,5〉 a epsilon1 a epsilon1epsilon1epsilon1 and A(epsilon1,epsilon1) → epsilon1 lead to A(〈1, 2〉,〈4, 5〉) ⇒ A(〈2, 2〉,〈5, 5〉) ⇒ epsilon1.
AnRCGissaidtobenoncombinatorial if each of the arguments in the right-hand sides of the clauses are single variables.
It is said to be linear if no variable appears more than once in the left-hand sides of the clauses and no variable appears more than once in the right-hand side of the clauses.
It is said to be nonerasing if for each clause, each variable occurring in the left-hand side occurs also in the right-hand side and vice versa.
It is said to be simple if it is noncombinatorial, linear, and nonerasing.
Simple RCGs and LCFRSs are equivalent (Boullier 1998b).
4.2 Relation
between RSN-MCTAG and Simple RCG The goal of this section is to construct an equivalent simple RCG for a given RSNMCTAG.
In order to be able to perform this construction, in the following we further constrain the formalism of RSN-MCTAG by defining RSN-MCTAG of a specific arity n.
For this version of RSN-MCTAG, the construction of an equivalent simple RCG is possible.
First, let us sketch the general idea of the transformation from TAG to RCG (see Boullier 1998a).
The RCG contains predicates 〈α〉(X)and〈β〉(L, R) for initial and auxiliary trees, respectively.
X covers the yield of α and all trees added to α,andL and R cover those parts of the yield of β (including all trees added to β) that are to the left and the right of the foot node of β.
The clauses in the RCG reduce the argument(s) of these predicates by identifying those parts that come from the elementary tree α/β itself and those parts that come from one of the elementary trees added by substitution or adjunction.
A sample TAG with an equivalent RCG is shown in Figure 13.
For the construction of an equivalent RCG from a given RSN-MCTAG, we follow the same ideas while considering a secondary adjunction of β at some γ as adjunction at γ and not as adjunction at the elementary tree that is the mother node of β in the TAG derivation tree.
There are two main differences between RSN-MCTAG and TAG that influence the construction of an equivalent RCG.
First, more than one tree can be added to a node.
Therefore we allow predicates of the form 〈αβ 1 ...β k 〉 and 〈β 0 β 1 ...β k 〉.
The first means that at the node in question, first α was added by substitution, and then β 1 ...β k (in this order) were secondarily adjoined.
The second means that at the node in question (an internal node), first β 0 was primarily adjoined, and then β 1 ...β k were secondarily adjoined.
Since the number of secondary adjunctions at a node is limited by some constant depending on the grammar 210 Kallmeyer Multicomponent TAGs with Shared Nodes Figure 13 A sample TAG and an equivalent RCG.
(see Lemma 3), k is limited as well, and therefore this extension with respect to TAG adds only a finite number of predicates.
Second, the contribution of an elementary tree α/β including the trees added to it can be separated into arbitrarily many parts.
Since each of the arguments of the predicates in the RCG has to cover a true substring of the input string, one needs predicates of arbitrary arities, namely, 〈α...〉(L n,..., L 1, X, R 1,..., R n )and 〈β...〉(L n,..., L 1, L 0, R 0, R 1,..., R n ), for the case where n auxiliary trees were added at the root of α/β that were actually secondarily adjoined at some higher tree such that these n trees separate the contribution of α/β into 2n + 1/2n + 2 parts, respectively.
This extension is problematic, since it leads to an RCG with predicates of arbitrary arity: a dynamic RCG (Boullier 2001), a variant of RCG that is not polynomially parsable and that we therefore want to avoid.
For this reason, we need an additional constraint on theRSN-MCTAGsweemploy.
An example in which the contribution of an elementary tree is separated into three different parts is example (9), analyzed with the RSN-MCTAG in section 3.1 (see Figure 14).
In the derived tree, the VP das Fahrrad zu reparieren zu versuchen (the broken triangles), which is the contribution of versuchen, is separated into three parts, Figure 14 Analysis of example (9).
211 Computational Linguistics Volume 31, Number 2 since reparieren secondarily adjoins at versuchen and das Fahrrad secondarily adjoins at reparieren.
(9) ...dass[dasFahrrad] 1 er [t 1 zu reparieren] 2 dem Kunden [t 2 zu versuchen] ...that thebike he torepair thecustomer totry verspricht promises The crucial point in example (9) is that in the SN-derivation structure (see Figure 14), there are two crossings of secondary edges inside one group of secondary links.
This means that the contribution of versuchen is interrupted twice by arguments of verspricht (by Kunde and er).
In order to avoid predicates of arbitrary arity, we therefore limit the number of crossings of secondary links.
We define the arity of an RSN-MCTAG depending on the maximal number of crossings that are allowed.
First, we define special subgraphs of the SN-derivation structure, secondary groups.
These are subgraphs consisting of a chain of one primary substitution/adjunction and subsequent adjunctions at root or foot nodes such that there are secondary adjunctions along the whole chain.
For example, the nodes verspricht, zu versuchen, Kunde, zu reparieren, er,andFahrrad in the SN-derivation structure in Figure 14 form such a group.
For an SN-derivation structure of a certain arity, the number of crossings of secondary edges inside a single secondary group is then limited: For an SN-derivation structure of arity n, the number of crossings of secondary edges per secondary group is limited to n 2 − 1.
In other words, if i is the maximal number of crossings, then 2(i + 1) is the arity of the grammar.
Of course, the arity is chosen such that an equivalent RCG of the same arity can be constructed.
TAG, for example, is a grammar with 0 crossings, that is, an arity 2(0 + 1) = 2 if the grammar is viewed as an SN-MCTAG, and the corresponding RCG is actually of arity 2.
Definition 9 Let D SN =〈N,E〉 be a SN-derivation structure.
1. 〈N prime,E prime 〉 is a secondary group in D SN iff a114 N prime ={n 0, n 1,..., n k }⊆N for some k > 1 such that there are primary edges 〈n i, n i+1, p i 〉 for 0 ≤ i < k with p i ∈ IN ; a114 E prime ⊆ E such that for all n, n prime ∈ N, p ∈ IN w i t h 〈n, n prime, p〉∈E:if n, n prime ∈ N prime, then 〈n, n prime, p〉∈E prime ; a114 for all i,0< i < k, there are i 1, i 2 with i 1 ≤ i ≤ i 2, i 1 negationslash= i 2, such that 〈n i 1, n i 2, p〉∈E prime is a secondary edge in D for some p ∈ IN . 2.
D SN is of arity n iff for each secondary group 〈N prime,E prime 〉 in D SN with primary edges 〈n 0, n 1, p 0 〉, 〈n 1, n 2, p 1 〉, ..., 〈n k−1, n k, p k−1 〉 as above, there are at most i ≤ n 2 − 1 pairwise different sets of the form {j 0, j 1, j 2, j 3 } such that j 0 < j 1 < j 2 < j 3 and there are secondary edges 〈n j 0, n j 2, p 1 〉 and 〈n j 1, n j 3, p 2 〉 for some p 1, p 2 ∈ IN . Definition 10 Let G be an MCTAG, n ≥ 1.
G is a restricted tree-local MCTAG with shared nodes of arity n iff the set of trees generated by G, L T (G), is defined as the set of those trees that can be derived in G with an RSN-tree-local multicomponent TAG derivation tree such that the corresponding SN-derivation structure is of arity n.
212 Kallmeyer Multicomponent TAGs with Shared Nodes Figure 15 Sample RSN-MCTAG of arity four.
Consider a simple example of a construction of an equivalent RCG for a given RSN-MCTAG.
We choose an RSN-MCTAG of arity four, and we see that the arity of the corresponding RCG is four as well.
The RSN-MCTAG is shown in Figure 15.
Whether this grammar is considered to be a general RSN-MCTAG or an RSN-MCTAG of arity four does not matter in this case, since even in the general case, all possible SN-derivation structures are of arity four.
However, in the case of other RSN-MCTAGs, the restriction to a certain arity might exclude certain TAG derivation trees and thereby decrease the language generated by the grammar.
The language generated by the RSN-MCTAG in Figure 15 is {er zu kommen (zu versuchen) ∗ verspricht, zu kommen (zu versuchen) + er (zu versuchen) ∗ verspricht}.TheSNderivation structures corresponding to the different strings are shown in Figure 15.
The last one contains one crossing of secondary links; that is, the RSN-MCTAG is of arity four.
Now let us look at the corresponding RCG.
Since the arity of the RSN-MCTAG is four, the predicates of the corresponding RCG are of arity three (for initial trees) and four (for auxiliary trees).
The contribution of α 1 is never separated into parts, therefore the first and the third arguments of the predicate 〈α 1 〉 are always epsilon1.
Looking at the SN-derivation structures in Figure 15, we have three different possibilities for 〈α 1 〉: 213 Computational Linguistics Volume 31, Number 2 〈α 1 〉(epsilon1,LNVversprichtR,epsilon1) →〈β 2 〉(epsilon1,L,R,epsilon1)〈α β 2 〉(epsilon1,N,epsilon1)〈α 2 〉(epsilon1,V,epsilon1)| 〈β 1 β 2 〉(epsilon1,L,R,epsilon1)〈α β 2 〉(epsilon1,N,epsilon1)〈α β 1 〉(epsilon1,V,epsilon1)| 〈β 2 β 1 〉(epsilon1,L,R,epsilon1)〈α β 2 〉(epsilon1,N,epsilon1)〈α β 1 〉(epsilon1,V,epsilon1) The interesting part of the grammar is the clauses for 〈β 1 β 2 〉, where two trees were added to the same node and further adjunctions at the root of β 1 are possible.
The point is that the part covered by β 1 and the trees added to it can be separated into different substrings.
This leads to 〈β 1 β 2 〉(epsilon1,L 1 L 2 L 3,R 3 R 2 R 1,epsilon1) →〈β 1 〉(L 1,L 3,R 3,R 1 )〈β 2 〉(epsilon1,L 2,R 2,epsilon1) 〈β 1 β 2 〉(L 1,L 2 L 3,R 3 R 2,R 1 ) →〈β 1 〉(L 1,L 3,R 3,R 1 )〈β 2 〉(epsilon1,L 2,R 2,epsilon1) 〈β 1 β 2 〉(L 1 L 2,L 3,R 3,R 2 R 1 ) →〈β 1 〉(L 1,L 3,R 3,R 1 )〈β 2 〉(epsilon1,L 2,R 2,epsilon1) Concerning 〈β 2 β 1 〉, the contribution of β 2 cannot be separated into different parts, since nothing can be adjoined to β 2 . Consequently 〈β 2 β 1 〉(epsilon1,L 1 L 2,R 2 R 1,epsilon1) →〈β 2 〉(epsilon1,L 2,R 2,epsilon1)〈β 1 〉(epsilon1,L 1,R 1,epsilon1) 〈β 2 β 1 〉(L 1,L 2,R 2,R 1 ) →〈β 2 〉(epsilon1,L 2,R 2,epsilon1)〈β 1 〉(epsilon1,L 1,R 1,epsilon1) Concerning 〈β 1 〉(L 1, L 3, R 3, R 1 ), either (L 1, R 1 ) cover something adjoined to β 1 (this can only be β 1 ), or (L 1, R 1 ) cover something adjoined to something ...adjoined to β 1 . In this case, (L 3, R 3 ) cover β 1 and β 1 adjoined to its root, respectively.
This leads to 〈β 1 〉(L 1,L 2 V zu versuchen,R 2,R 1 ) →〈β 1 〉(L 1,L 2,R 2,R 1 )〈α β 1 〉(epsilon1,V,epsilon1) If the inner parts are empty, the outer parts are moved: 〈β 1 〉(L,epsilon1,epsilon1,R) →〈β 1 〉(epsilon1,L,R,epsilon1) Furthermore, there is a clause for 〈β 1 〉 without adjunction at the root: 〈β 1 〉(epsilon1,V zu versuchen,epsilon1,epsilon1) →〈α 2 〉(epsilon1,V,epsilon1) For elementary trees where nothing needs to be added, simple epsilon1-clauses are introduced: 〈α 2 〉(epsilon1, zukommen,epsilon1) →epsilon1 〈α β 1 〉(epsilon1,epsilon1,epsilon1) →epsilon1 〈β 2 〉(epsilon1,er,epsilon1,epsilon1) →epsilon1 〈α β 2 〉(epsilon1,epsilon1,epsilon1) →epsilon1 In order to see how the RCG simulates the RSN-MCTAG, let us consider the derivation for zu kommen zu versuchen er zu versuchen verspricht: 〈α 1 〉(epsilon1,zukommenzuversuchener zuversuchenverspricht,epsilon1) ⇒〈β 1 β 2 〉(epsilon1,zukommenzuversuchener zuversuchen,epsilon1,epsilon1)〈α β 2 〉(epsilon1,epsilon1,epsilon1)〈α β 1 〉(epsilon1,epsilon1,epsilon1) ∗ ⇒〈β 1 〉(zukommenzuversuchen, zuversuchen,epsilon1,epsilon1)〈β 2 〉(epsilon1,er,epsilon1,epsilon1) ∗ ⇒〈β 1 〉(zukommenzuversuchen,epsilon1,epsilon1,epsilon1)〈α β 1 〉(epsilon1,epsilon1,epsilon1) ∗ ⇒〈β 1 〉(epsilon1,zukommenzuversuchen,epsilon1,epsilon1) ⇒〈α 2 〉(epsilon1,zukommen,epsilon1) ⇒epsilon1 214 Kallmeyer Multicomponent TAGs with Shared Nodes This example should give an idea of how an equivalent RCG for a given RSN-MCTAG of arity n can be constructed.
As already mentioned, in an RSN-MCTAG, the number of substitutions and (primary or secondary) adjunctions that can occur at each node is limited (see Lemma 3).
Therefore, the number of predicates needed in the corresponding RCG is limited as well.
Furthermore, in an RSN-MCTAG of arity n, the contribution of an elementary tree is separated into at most n parts.
This still needs to be shown: Lemma 4 Let G be an RSN-MCTAG of arity n.
Then for all w in the string language of G and for all elementary trees γ used to derive w in G, the contribution of γ, that is, the yield of γ and everything added to γ, is separated into at most n parts.
The proof is given in the appendix.
Theorem 1 For each RSN-MCTAG G of arity n, a simple RCG G prime of arity n can be constructed such that L(G) = L(G prime ).
The construction algorithm and a sketch of the proof are presented in the appendix.
As a consequence of this theorem, the following corollary holds: Corollary For a given n, the string languages generated by RSN-MCTAGs of arity n are mildly context-sensitive, and they are in particular polynomially parsable.
Since we have shown that for RSN-MCTAG with a fixed arity, one obtains grammars that are LCFRSs, we know that we can even construct a weakly equivalent setlocal MCTAG.
This set-local MCTAG, however, does not present an alternative to the RSN-MCTAG with fixed arity: It is very large, containing a large number of elementary trees per tree set (the number depends on the arity of the grammar) and, furthermore, a large number of trees without lexical material and a large number of internal nodes that are needed only to provide adjunction sites.
An example is the set-local MCTAG in Figure 16.
It is weakly equivalent to the RSN-MCTAG of arity four in Figure 15, and it even gives the correct dependency structure.
The verspricht tree contains several VP nodes that are needed in order to provide adjunction sites for the different parts of er and versuchen.Theversuchen tree set needs an extra auxiliary tree that provides an additional VP node for adjunction and has to be separated from the tree containing versuchen, since the contribution of versuchen might be separated into different parts.
Of course this little grammar is still simple, since there are almost no possibilities of adjoining different trees at the same node or of separating the contribution of one lexical item into different parts.
As we have seen in Lemma 4, the linguistic signification of restricting the arity of the grammar to some n is that the lexical material containing a verb, all its arguments (including arguments and adjuncts of these arguments, etc.), and all its adjuncts cannot be separated into more than n discontinuous substrings in the whole sentence.
For example, an RSN-MCTAG of arity two with elementary tree sets similar to those proposed above for scrambling would not be able to analyze example (9).
However, RSN-MCTAGs of arity n for some sufficiently large fixed n can perhaps even describe 215 Computational Linguistics Volume 31, Number 2 Figure 16 Equivalent set-local MCTAG for the RSN-MCTAG from Figure 15.
all cases of scrambling: See again the analysis of example (9) in Figure 14.
Here, the contribution of versuchen and its arguments is split only by other elements secondarily adjoined to verspricht.
If only a limited number of such secondary adjunctions were possible (this is the case), and if none of these other secondarily adjoined elements allowed for further secondary adjunctions at its root or foot node (this still needs to be investigated), then the number of crossings might be limited.
We leave this issue for further research.
Even if RSN-MCTAG with a fixed arity could not analyze all scrambling data, based on empirical studies, n could be chosen sufficiently great such that the grammar would cover all scrambling cases that one assumes to occur.
16 The
important point is that the complexity limit given by the fixed n is variable; that is, an arbitrary n can be chosen.
This is different from TAG, for example, in which the limit is fixed (assuming, of course, that we desire only analyses respecting the CETM).
In this sense one can say that RSNMCTAG can analyze scrambling in general.
5. Conclusion and Future Work This article addresses the problem of scrambling in tree-adjoining grammar, a formalism known not to be powerful enough to treat scrambling phenomena.
In order to keep the advantages of TAG while being able to analyze scrambling, a local TAG variant is proposed that is based on the notion of node sharing, so-called (restricted) tree-local multicomponent TAG with node sharing.
RSN-MCTAG is a true extension of TAG in the sense that the formalism can generate all tree-adjoining languages.
The analysis of some German scrambling data is sketched in order to show that this TAG extension can treat scrambling.
Then, RSN-MCTAGs of specific arities are defined, and it is shown that for each RSN-MCTAG of a fixed arity n, an equivalent simple RCG of arity n can be constructed.
Simple RCGs are mildly context-sensitive and in particular polynomially parsable and therefore, this also holds for RSN-MCTAGs of a fixed arity.
RSN-MCTAGs of arity n perhaps cannot analyze all scrambling phenomena but, if the n is appropriately chosen, it can analyze an arbitrarily large set.
16 Joshi, Becker, and Rambow (2000) even argue that there might be a competence limit regarding the complexity of scrambling data.
However, we do not discuss this issue here.
216 Kallmeyer Multicomponent TAGs with Shared Nodes The scrambling data analyzed in section 3 present just a small part of the possible scrambling configurations.
As already noted, this article does not present an exhaustive treatment of the phenomenon.
Even though the examples we looked at indicate that RSN-MCTAGs are able to deal with scrambling, an exhaustive analysis of a larger amount of data still needs to be done, in particular, of scrambling in combination with other “movements” that cause word order variations, such as topicalization or extraposition.
A first proposal in this direction can be found in Kallmeyer and Yoon (2004), but this proposal does not cover all phenomena one needs to take into account.
So this is still an important issue for further research.
A formal issue one would like to see investigated more in detail is the relations between the different types of MCTAG.
We have shown that the languages of RSNMCTAG with fixed arity are in the class of set-local MCTALs.
Furthermore, general SN-MCTAG can generate languages that cannot be generated by set-local MCTAG.
However, this leaves open many interesting questions concerning the relations between set-local MCTAG and non-local MCTAG and the different formalisms defined in this article, namely, RSN-MCTAG of fixed arity and RSN-MCTAG and MCTAG with SN-tree-local and SN-set-local derivations.
We plan to address these questions in the future.
Appendix: Proofs Proof of Lemma 1 Let G =〈I, A, N, T,A〉 be an MCTAG, G TAG :=〈I, A, N, T〉.LetD =〈N,E〉 be a derivation tree in G TAG with corresponding derived tree t ∈ L(G TAG ).
1. First show ⇒ of the iff: Let D be a TAG derivation tree with t ∈ L(G).
It is immediate that the root of D is an instance of an initial tree and that all other nodes are elements of instances of elementary tree sets.
Assume that a114 either there is an instance Γ of elementary tree sets from A such that there are γ 1,γ 2 ∈Γ,withγ 1 ∈ N and γ 2 negationslash∈ N,andγ 1 is not the root of D.
⇒ it is not possible that Γ has been used in one of the multicomponent derivation steps in the course of the derivation of t.
Contradiction. a114 or there is an instance Γ of an elementary tree set such that there are γ 1,γ 2 ∈Γ, γ 1 negationslash= γ 2,with〈γ 1,γ 2 〉∈D D ⇒γ 2 has been added to a tree derived from γ 1 . Contradiction to condition that all elements of Γ must have been added simultaneously.
a114 or there are pairwise different instances Γ 1,Γ 2,...,Γ n of elementary tree sets from A such that there are γ (i) 1,γ (i) 2 ∈Γ i,1≥ i ≥ n,with 〈γ (1) 1,γ (n) 2 〉∈D D and 〈γ (i) 1,γ (i−1) 2 〉∈D D for 2 ≥ i ≥ n.
⇒γ (i) 1 was added before γ (i−1) 2 for 2 ≤ i ≤ n, and since all elements from Γ i must be added simutaneously for 1 ≤ i ≤ n, Γ n was added before Γ 1 . ⇒〈γ (1) 1,γ (n) 2 〉 negationslash∈ D D . Contradiction.
Consequently, D satisfies (MC1)–(MC3).
2. Then show ⇐ of the iff: Let D be a derivation tree in G TAG satisfying (MC1)– (MC3).
217 Computational Linguistics Volume 31, Number 2 There are different orderings of the derivation steps in D possible: Let the node positions on the derived tree be pairs 〈γ, p〉,withγ being an instance of an elementary tree and p being a position in γ.
Every top-down order read off D (no matter whether [partly] depth first or not and whether left to right or right to left) is a possible derivation order in G TAG for the derivation tree D, since in order to perform the derivation step ...[〈γ 1, p〉,γ 2 ] corresponding to an edge 〈γ 1,γ 2, p〉 in D, one needs only to ensure that γ 1 (i.e., the mother node of γ 2 ) has already been added.
Because of (MC1), the root of D is an initial tree, and the set of all other nodes in D can be partitioned into pairwise different instances of elementary tree sets.
To show: There is a top-down traversal of D such that the traversal starts with an initial tree and then there is always one instance Γ of an elementary set whose members are visited next in any order (i.e., simultaneously).
The top-down traversal has to start with the root node (i.e., an initial tree α).
Assume that at some point of the traversal, the choice of a new instance of an elementary set to be visited next is not possible.
⇒ for each set Γ that has not been visited yet, there is at least one γ ∈Γ whose mother node has not been visited yet (otherwise Γ could be visited next).
Pick an unvisitedΓ 1 with at least one γ (1) 1 ∈Γ 1 whose mother node has been visited.
Assume γ (1) 2 ∈Γ 1 with mother not yet visited.
Suppose γ (2) 1 to be the highest unvisited node dominating γ (1) 2 . Since γ (2) 1 negationslash= γ (1) 2 and 〈γ (2) 1,γ (1) 2 〉∈D D,(with(MC2))γ (2) 1 ∈Γ 2 negationslash= Γ 1 . Then there is a γ (2) 2 ∈Γ 2 with unvisited mother such that (a) either 〈γ (1) 1,γ (2) 2 〉∈D D . Contradiction to (MC3) with n = 2.
γ (1) 1 γ (2) 1 γ (2) 2 γ (1) 2 (b) or 〈γ (1) 1,γ (2) 2 〉 /∈ D D . Because of (MC2), 〈γ (2) 1,γ (2) 2 〉 /∈ D D .Letγ (3) 1 ∈Γ 3 be the highest unvisited node dominating γ (2) 2 . Because of (MC2), Γ 3 negationslash=Γ 2,and because of (MC3), Γ 3 negationslash=Γ 1 . γ (1) 1 γ (2) 1 γ (3) 1 γ (1) 2 γ (2) 2 In the (b) case, there is a γ (3) 2 ∈Γ 3 with unvisited mother node.
Because of (MC2) and (MC3), 〈γ (1) 1,γ (3) 2 〉 /∈ D D, 〈γ (2) 1,γ (3) 2 〉 /∈ D D,and〈γ (3) 1,γ (3) 2 〉 /∈ D D . Then there is a highest unvisited node γ (4) 1 ∈Γ 4 dominating γ (3) 2 with Γ 4 negationslash=Γ 3,Γ 4 negationslash=Γ 2,andΓ 4 negationslash=Γ 1 . And there is a γ (4) 2 ∈Γ 4 with unvisited mother node.
In general, for each of the Γ n,1≤ n,withγ (n) 1,γ (n) 2 as above, the situation is as follows: Γ n negationslash=Γ i for 1 ≤ i < n (otherwise contradiction to (MC2) or (MC3)) and 〈γ (i) 1,γ (n) 2 〉 /∈ D D for i ≤ n (otherwise contradiction to (MC2) for i = n or to (MC3) 218 Kallmeyer Multicomponent TAGs with Shared Nodes for i negationslash= n).
Consequently, there is always a new Γ n+1, with a new γ (n+1) 1 being the highest unvisited node dominating γ (n) 2 and γ (n+1) 2 being a node with unvisited mother.
γ (1) 1 γ (2) 1 γ (n) 1 γ (n+1) 1 γ (1) 2 ...
γ (n−1) 2 γ (n) 2 Contradiction to the finiteness of the number of nodes in D.
⇒ there is a top-down traversal of D that corresponds to a multicomponent derivation in G in the sense that it allows us to visit the instances of elementary tree sets one after the other.
squaresolid Proof of Lemma 2 Only the uniqueness needs to be shown.
Let G =〈I, A, N, T,A〉 be an RSN-MCTAG.
Let D =〈N,E〉 be a TAG derivation tree in G.
Assume that there is an instance {γ 1,...,γ n } of an elementary tree set such that there are γ,γ prime with γ negationslash= γ prime and 〈γ,γ 1 〉,...,〈γ,γ n 〉,〈γ prime,γ 1 〉,...,〈γ prime,γ n 〉∈SN D and there are i, j,1≤ i, j ≤ n with 〈γ,γ i 〉,〈γ prime,γ j 〉∈P D . ⇒ since 〈γ prime,γ j 〉∈P D and 〈γ,γ j 〉∈D D with γ negationslash= γ j, there is a γ primeprime with 〈γ,γ primeprime 〉∈P D and 〈γ primeprime,γ prime 〉∈D D . Furthermore, 〈γ i,γ primeprime 〉 /∈ D D (otherwise 〈γ i,γ j 〉∈D D which would contradict (MC2)) and 〈γ primeprime,γ i 〉 /∈ D D (otherwise, since γ i negationslash= γ primeprime, 〈γ,γ i 〉 /∈ P D ).
Consequently 〈γ prime,γ i 〉 /∈ D D . Contradiction to assumption.
squaresolid Proof of Lemma 4 Let G be an RSN-MCTAG of arity n, w ∈ L(G), such that the elementary tree γ was used to derive w.
Assume that the contribution of γ is separated into m > n parts.
Then the SN-derivation structure for this derivation is as shown in Figure 17.
Consequently, there are at least ceilingleft m 2 − 1ceilingright crossings, and the arity of G is (ceilingleft m 2 − 1ceilingright+ 1)· 2.
⇒ if m is even, G is of arity m,andifm is odd, G is of arity m + 1.
This is a contradiction to the assumption that the arity of G is n < m.
squaresolid Proof of Theorem 1 For reasons of space, we do not give the whole proof of the theorem but restrict ourselves to the construction algorithm and a rough outline of the rest of the proof.
Construction algorithm.
Let G be an RSN-MCTAG of arity n.
Construction of a weakly equivalent RCG G prime : The terminals and nonterminals will be implicitly defined by the clauses of the grammar.
Predicates: Let k 1 be the maximal number of nodes in an elementary tree in G and k 2 be the maximal number of trees in an elementary tree set.
k := k 1 (k 2 − 1).
219 Computational Linguistics Volume 31, Number 2 Figure 17 SN-derivation structure for proof of Lemma 4.
a114 There is a unary predicate S.
a114 Each 〈α〉 and each 〈αβ 1 ···β l 〉,withl < k, α an initial tree, and β 1,...,β l auxiliary trees is an n − 1-ary predicate.
a114 Each 〈β〉 and each 〈ββ 1 ···β l 〉 with l < k and β,β 1,...,β l auxiliary trees is an n-ary predicate.
Define the decoration string σ γ of an elementary tree γ as in Boullier (1999), except that a root node µ has n variables, L µ 1 ...L µ n 2 on the left and R µ n 2 ...R µ 1 on the right.
Every other internal node µ has two variables L µ and R µ, and each substitution node has one variable X.
In a top-down, left-to-right traversal, the left variables are collected during the top-down traversal, the terminals and variables of substitution nodes are collected while visiting the leaves, and the right variables are collected during bottomup traversal.
Construction of the clauses: In the following, P(epsilon1,...,epsilon1, x,epsilon1,...,epsilon1) signifies that x is the n 2 th argument, and P(epsilon1,...,epsilon1, x 1, x 2,epsilon1,...,epsilon1) signifies that x 1 is the n 2 th and x 2 the ( n 2 + 1)th argument.
220 Kallmeyer Multicomponent TAGs with Shared Nodes (1) Predicate S For each initial α, there is a clause S(X) →〈α〉(epsilon1,...,epsilon1,X,epsilon1,...,epsilon1) (2) Predicates 〈γ〉 For each elementary γ: lhs := σ γ, rhs := epsilon1.
For each combination of substitutions and adjunctions at γ, with substitutions at all substitution nodes and adjunctions at all internal nodes, with obligatory adjunction that respects the conditions for restricted tree-local multicomponent derivation: For all nodes µ in γ: a114 If µ is an internal node that is not the root, and no adjunction takes place at µ, then delete L µ and R µ in lhs.
a114 If µ is the root node and no adjunction takes place at µ, then delete L µ 1 ···L µ n 2 and R µ n 2 ···R µ 1 in lhs.
a114 If only the initial tree α is substituted at µ, rhs :=〈α〉(epsilon1,...,epsilon1, S µ,epsilon1,...,epsilon1)rhs.
a114 If α is substituted at µ and then β 1,...,β m (in that order) are secondarily adjoined at µ, then rhs :=〈αβ 1 ···β m 〉(epsilon1,...,epsilon1, S µ,epsilon1,...,epsilon1)rhs.
a114 If µ is an internal node that is not the root and β 1,...,β m are adjoined (in that order) at µ, then rhs :=〈β 1 ···β m 〉(epsilon1,...,epsilon1, L µ, R µ,epsilon1,...,epsilon1)rhs.
If there is no adjunction at the root of γ, there is a clause 〈γ〉(epsilon1,...,epsilon1,lhs,epsilon1,...,epsilon1) → rhs If β 1,...,β m are adjoined in this order at the root of γ,andifL 1,..., L n 2, R n 2,..., R 1 are the parts of the root in lhs such that lhs = L 1 ···L n 2 lhs prime R n 2 ···R 1, then there is a clause 〈γ〉(L 1,...,Ln 2 −1,Ln 2 lhs prime Rn 2,Rn 2 −1,...,R 1 ) → 〈β 1 ···β m 〉(L 1,...,Ln 2,Rn 2,...,R 1 )rhs Further, for each initial γ and for all i,1≤ i ≤ n 2 − 2, there are clauses 〈γ〉(L 1,...,L i,epsilon1,L i+1,...,Ln 2 −2,X,Rn 2 −2,...,R i+1,epsilon1,R i,...,R 1 ) → 〈γ〉(epsilon1,L 1,...,Ln 2 −2,X,Rn 2 −2,...,R 1,epsilon1) And for each auxiliary γ and for all i,1≤ i ≤ n 2 − 1, there are clauses 〈γ〉(L 1,...,L i,epsilon1,L i+1,...,Ln 2 −1,Rn 2 −1,...,R i+1,epsilon1,R i,...,R 1 ) → 〈γ〉(epsilon1,L 1,...,Ln 2 −1,Rn 2 −1,...,R 1,epsilon1) 221 Computational Linguistics Volume 31, Number 2 (3) Predicates 〈γ 1 γ 2 ···γ m 〉 For each 〈γ 1 γ 2 ···γ m 〉 with m ≥ 2 occurring in the clauses constructed so far: Define sets of variables L := {L 1 (γ 1 ),...,Ln 2 (γ 1 ),L 1 (γ 2 ),...,Ln 2 (γ m )}, and R := {R 1 (γ 1 ),...,Rn 2 (γ 1 ),R 1 (γ 2 ),...,Rn 2 (γ m )}, and three other pairwise different variables X 1,X 2,X /∈L∪R.
Define for all x ∈ L ∗ : R(x):= y ∈ R ∗ such that if L j (γ i )isthekth letter of x, then R j (γ i ) is the (|x|−k + 1)th letter of y.
For all w ∈ L ∗ such that (a) each L ∈ L occurs exactly once in w, (b) for all 1 ≤ i 1 < i 2 ≤ m, L n 2 (γ i 1 )istotherightofL n 2 (γ i 2 )inw,and (c) for all 1 ≤ i ≤ m and 1 ≤ j 1 < j 2 ≤ n 2, L j 1 (γ i )istotheleftofL j 2 (γ i )inw, and for all x 1,..., x n 2 ∈ L ∗ with x 1 ···x n 2 = w, there is the following clause: If γ 1 is an initial tree, a clause with L n 2 (γ 1 ) eliminated from the x 1,..., x n 2 : 〈γ 1 ···γ m 〉(x 1,...,xn 2 XR(xn 2 ),...,R(x 1 ))→ 〈γ 1 〉(L 1 (γ 1 ),...,Ln 2 −1 (γ 1 ),X,Rn 2 −1 (γ 1 ),...,R 1 (γ 1 )) 〈γ 2 〉(L 1 (γ 2 ),...,Ln 2 (γ 2 ),Rn 2 (γ 2 ),...,R 1 (γ 2 )) . . . 〈γ m 〉(L 1 (γ m ),...,Ln 2 (γ m ),Rn 2 (γ m ),...,R 1 (γ m )) If γ 1 is an auxiliary tree, a clause 〈γ 1 ···γ m 〉(x 1,...,xn 2,R(xn 2 ),...,R(x 1 ))→ 〈γ 1 〉(L 1 (γ 1 ),...,Ln 2 (γ 1 ),Rn 2 (γ 1 ),...,R 1 (γ 1 )) . . . 〈γ m 〉(L 1 (γ m ),...,Ln 2 (γ m ),Rn 2 (γ m ),...,R 1 (γ m )) (4) These are all clauses.
Sketch of Proof.
We do not give the whole proof of the correctness of the construction, but we sketch the principal steps: Mainly, two lemmas, concerning, respectively, the clauses constructed under paragraph 2 above and under paragraph 3 above, are shown: Lemma 5 For each elementary tree γ in G with decoration string σ γ as defined above: There is a γ prime derived from γ with yield w (if γ is an initial tree) or 〈w l, w r 〉 (if γ is an auxiliary tree with w l on the left and w r on the right of the foot node) such that a114 all leaves in γ prime have terminal labels; a114 there are no OA constraints in γ prime ; 222 Kallmeyer Multicomponent TAGs with Shared Nodes a114 for all node positions p in γ at which substitutions or adjunctions took place, the elementary trees γ (p) 1,γ (p) 1,...,γ (p) m (in that order) were substituted/adjoined at the node at position p in γ (these are all trees attached to this node).
iff There is a 〈γ〉-clause in G prime corresponding to the attachments to γ in this derivation in the way described in the construction, with σ prime being the decoration string of γ without the symbols for the nodes to which nothing was attached such that There is an instantiation f : {t prime |t prime is an occurrence of some t ∈ T in σ prime }∪V → {〈i, j〉|0 ≤ i ≤ j ≤|w|} as defined in Definition 8, and the following hold for f : a114 For each substitution node µ in γ with position p, the yield of the trees γ (p) 1,γ (p) 1,...,γ (p) m and everything added to them is the connected substring f (S µ ), even if the derivation of γ prime from γ is part of a larger derivation.
a114 For each internal node µ in γ with position p at which adjunctions took place, the yield of the trees γ (p) 1,γ (p) 1,...,γ (p) m consists of the two connected substrings 〈 f (L µ ), f (R µ )〉, even if the derivation of γ prime from γ is part of a larger derivation.
a114 If adjunctions at the root took place, then the yield of the trees γ (p) 1,γ (p) 1,...,γ (p) m consists of the substrings 〈 f (L 1 )f (L 2 )···f (L n 2 ), f (R n 2 )···f (R 1 )〉, and this yield can be disconnected if the derivation of γ prime from γ is part of a larger derivation; it can be separated into disconnected substrings f (L 1 ), f (L 2 ),..., f (L n 2 ), f (R n 2 ),..., f (R 1 ).
Proof by induction on structure of γ.
Lemma 6 For all γ 1,γ 2,...,γ m : There is a derivation in G of a tree with yield w in which γ 1,γ 2,...,γ m (in that order) attach to some node µ in an elementary tree γ such that the yield of the trees γ 1,γ 2,...,γ m is separated into at most n disconnected substrings (ranges) of w.Ifγ 1 is an auxiliary tree, it is separated into the substrings l 1,..., l n 2, r n 2,..., r 1 ; otherwise (γ 1 initial), the substrings are l 1,..., l n 2 −1, x, r n 2 −1,..., r 1 . iff There is a 〈γ 1 γ 2 ···γ m 〉-clause as described in paragraph 3 of the construction above such that there is an instantiation f of the clause such that a114 If γ 1 is initial, then f (x 1 ) = l 1,..., f (x n 2 −1 ) = l n 2 −1, f (x n 2 XR(x n 2 )) = x, f (R(x n 2 −1 )) = r n 2 −1,..., f (R(x 1 )) = r 1,andifγ 1 is auxiliary, then f (x 1 ) = l 1,..., f (x n 2 ) = l n 2 1, f (R(x n 2 )) = r n 2,..., f (R(x 1 )) = r 1 . a114 If γ 1 is initial, then its yield in w consists of the n − 1 substrings (ranges) f (L 1 (γ 1 )),..., f (L n 2 −1 (γ 1 )), f (X), f (R n 2 −1 (γ 1 )),..., f (R 1 (γ 1 )).
a114 For all auxiliary γ i,1≤ i ≤ m, the yield of γ i in w consists of the n substrings (ranges) f (L 1 (γ i )),..., f (L n 2 (γ i )), f (R n 2 (γ i )),..., f (R 1 (γ i )).
Proof by induction on m.
The whole theorem can then be proven using these two lemmas.
223 Computational Linguistics Volume 31, Number 2 Acknowledgments For valuable suggestions, helpful comments and fruitful discussions of the subject of this article, we would like to thank Anne Abeill´e, Pierre Boullier, David Chiang, Eric de la Clergerie, Chung-Hye Han, Aravind Joshi, Tony Kroch, Seth Kulick, Maribel Romero and SinWon Yoon.
Furthermore, we are really grateful to three anonymous reviewers who gave many very helpful comments and whose suggestions for improvements influenced considerably the final form of the article.
References Becker, Tilman, Aravind K.
Joshi, and Owen Rambow.
1991. Long-distance scrambling and tree adjoining grammars.
In Proceedings of ACL-Europe, Berlin.
Becker, Tilman, Owen Rambow, and Michael Niv.
1992. The derivational generative power of formal systems, or Scrambling is beyond LCFRS.
Technical Report IRCS-92-38, Institute for Research in Cognitive Science, University of Pennsylvania.
Bertsch, Eberhard and Mark-Jan Nederhof.
2001. On the complexity of some extensions of RCG parsing.
In Proceedings of the Seventh International Workshop on Parsing Technologies, pages 66–77, Beijing, October.
Boullier, Pierre.
1998a. A generalization of mildly context-sensitive formalisms.
In Proceedings of the Fourth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+4), pages 17–20, University of Pennsylvania, Philadelphia.
Boullier, Pierre.
1998b. A proposal for a natural language processing syntactic backbone.
Technical Report 3342, Institut National de Recherche en Informatique et en Automatique (INRIA) Rocquencourt.
Boullier, Pierre.
1999. On TAG parsing.
In Proceedings of TALN 99: Sixi`eme Conf´erence Annuelle sur le Traitement Automatique des Langues Naturelles, pages 75–84, Carg`ese, Corse, July.
Boullier, Pierre.
2000. Range concatenation grammars.
In Proceedings of the Sixth International Workshop on Parsing Technologies (IWPT2000), pages 53–64, Trento, Italy, February.
Boullier, Pierre.
2001. From contextual grammars to range concatenation grammars.
In Proceedings of the Sixth Conference on Formal Grammar and Seventh Conference on Mathematics of Language (FG/MOL’01), Helsinki, August.
Candito, Marie-H´el`ene and Sylvain Kahane.
1998. Can the TAG derivation tree represent a semantic graph?
An answer in the light of meaning-text theory.
In Proceedings of the Fourth International Workshop on Tree Adjoining Grammars and Related Formalisms, IRCS Report 98–12, pages 25–28, University of Pennsylvania, Philadelphia.
Dras, Mark, David Chiang, and William Schuler.
2004. On relations of constituency and dependency grammars.
Research on Language and Computation, 2(2):281–305.
Frank, Robert.
1992. Syntactic Locality and Tree Adjoining Grammar: Grammatical, Acquisition and Processing Perspectives.
Ph.D. thesis, University of Pennsylvania.
Frank, Robert.
2002. Phrase Structure Composition and Syntactic Dependencies.
MIT Press, Cambridge, MA.
Gerdes, Kim.
2002. Topologie et grammaires formelles de l’allemand.
Ph.D. thesis, Universit´e Paris 7.
Joshi, Aravind K.
1985. Tree adjoining grammars: How much context sensitivity is required ro provide reasonable structural descriptions?
In D.
Dowty, L.
Karttunen, and A.
Zwicky, editors, Narural Language Parsing.
Cambridge University Press, Cambridge, pages 206–250.
Joshi, Aravind K.
1987. An introduction to tree adjoining grammars.
In A.
Manaster-Ramer, editor, Mathematics of Language.
John Benjamins, Amsterdam, pages 87–114.
Joshi, Aravind K., Tilman Becker, and Owen Rambow.
2000. Complexity of scrambling: A new twist to the competence/ performance distinction.
In Anne Abeill´e and Owen Rambow, editors, Tree Adjoining Grammars: Formalisms, Linguistic Analyses and Processing.
Center for the Study of Language and Information (CSLI) Publications, Stanford, CA, pages 167–181.
Joshi, Aravind K., Leon S.
Levy, and Masako Takahashi.
1975. Tree adjunct grammars.
Journal of Computer and System Science, 10:136–163.
Joshi, Aravind K.
and Yves Schabes.
1997. Tree-adjoining grammars.
In G.
Rozenberg and A.
Salomaa, editors, Handbook of Formal Languages.
Springer, Berlin, pages 69–123.
Joshi, Aravind K.
and K.
Vijay-Shanker. 1999.
Compositional semantics with lexicalized tree-adjoining grammar (LTAG): How much underspecification is necessary?
In H.
C. Blunt and E.
G. C.
Thijsse, editors, Proceedings of the Third International Workshop on Computational Semantics (IWCS-3), pages 131–145, Tilburg, The Netherlands.
Kallmeyer, Laura.
2001. Local tree description grammars: A local extension of TAG allowing underspecified dominance relations.
Grammars, 4:85–137.
Kallmeyer, Laura.
2002. Using an enriched TAG derivation structure as basis for semantics.
In Proceedings of TAG+6 Workshop, pages 127–136, Venice, May.
Kallmeyer, Laura and Aravind K.
Joshi. 2003.
Factoring predicate argument and scope semantics: Underspecified semantics with LTAG.
Research on Language and Computation, 1(1–2):3–58.
Kallmeyer, Laura and Sinwon Yoon.
2004. Tree-local MCTAG with shared nodes: Word order variation in German and Korean.
In Proceedings of TAG+7, Vancouver.
Kulick, Seth Norman.
2000. Constraining Non-local Dependencies in Tree Adjoining Grammar: Computational and Linguistic Perspectives.
Ph.D. thesis, University of Pennsylvania.
Rambow, Owen.
1994a. Formal and Computational Aspects of Natural Language Syntax.
Ph.D. thesis, University of Pennsylvania.
Rambow, Owen.
1994b. Multiset-valued linear index grammars: Imposing dominance constraints on derivations.
In Proceedings of ACL,LasCruces, NM.
Rambow, Owen and Young-Suk Lee.
1994. Word order variation and tree-adjoining grammars.
Computational Intelligence, 10(4):386–400.
Rambow, Owen, K.
Vijay-Shanker, and David Weir.
1995. D-tree grammars.
In Proceedings of ACL, Cambridge, MA.
Rambow, Owen, K.
Vijay-Shanker, and David Weir.
2001. D-tree substitution grammars.
Computational Linguistics, 27(1):87–121.
Rogers, James.
1994. Studies in the Logic of Trees with Applications to Grammar Formalisms.
Ph.D. thesis, University of Delaware.
Schabes, Yves.
1990. Mathematical and Computational Aspects of Lexicalized Grammars.
Ph.D. thesis, University of Pennsylvania.
Schabes, Yves and Stuart M.
Shieber. 1994.
An alternative conception of tree-adjoining derivation.
Computational Linguistics, 20(1):91–124.
Vijay-Shanker, K.
1987. AStudyofTree Adjoining Grammars.
Ph.D. thesis, University of Pennsylvania.
Vijay-Shanker, K.
1992. Using descriptions of trees in a tree adjoining grammar.
Computational Linguistics, 18(4):481–517.
Vijay-Shanker, K.
and Aravind K.
Joshi. 1988.
Feature structures based tree adjoining grammar.
In Proceedings of COLING,pages 714–719, Budapest.
Weir, David J.
1988. Characterizing mildly context-sensitive grammar formalisms.
Ph.D. thesis, University of Pennsylvania.
XTAG Research Group.
1998. A lexicalized tree adjoining grammar for English.
Technical Report IRCS 98-18, Institute for Research in Cognitive Science, University of Pennsylvania .

